<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="PDF Audio Player">
<title>PDF Audio Player</title>
<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">
<!-- Theme color for address bar -->
<meta name="theme-color" content="#f5f5f7">
<!-- iOS specific meta tags -->
<meta name="apple-touch-fullscreen" content="yes">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">
<link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
<link rel="apple-touch-icon" sizes="167x167" href="icons/icon-192x192.png">
<!-- Standard favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512x512.png">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js"></script>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
-webkit-tap-highlight-color: transparent;
-webkit-touch-callout: none;
}
:root {
--bg-gradient-start: #f5f5f7;
--bg-gradient-mid: #fafafa;
--bg-gradient-end: #f0f0f2;
--glass-bg: rgba(255, 255, 255, 0.7);
--glass-border: rgba(255, 255, 255, 0.3);
--card-bg: rgba(255, 255, 255, 0.8);
--card-border: rgba(255, 255, 255, 0.5);
--text-primary: rgba(0, 0, 0, 0.8);
--text-secondary: rgba(0, 0, 0, 0.6);
--text-tertiary: rgba(0, 0, 0, 0.4);
--input-bg-start: rgba(255, 255, 255, 0.9);
--input-bg-end: rgba(255, 255, 255, 0.7);
--viewer-bg: rgba(255, 255, 255, 0.5);
--shadow-color: rgba(0, 0, 0, 0.1);
--inset-shadow: rgba(255, 255, 255, 0.8);
--slider-track: rgba(174, 174, 178, 0.3);
--slider-thumb: #86868b;
--slider-thumb-shadow: rgba(134, 134, 139, 0.3);
}
body.dark-mode {
--bg-gradient-start: #1c1c1e;
--bg-gradient-mid: #2c2c2e;
--bg-gradient-end: #1c1c1e;
--glass-bg: rgba(44, 44, 46, 0.8);
--glass-border: rgba(84, 84, 88, 0.3);
--card-bg: rgba(58, 58, 60, 0.8);
--card-border: rgba(84, 84, 88, 0.5);
--text-primary: rgba(255, 255, 255, 0.9);
--text-secondary: rgba(255, 255, 255, 0.6);
--text-tertiary: rgba(255, 255, 255, 0.4);
--input-bg-start: rgba(58, 58, 60, 0.9);
--input-bg-end: rgba(44, 44, 46, 0.7);
--viewer-bg: rgba(28, 28, 30, 0.6);
--shadow-color: rgba(0, 0, 0, 0.3);
--inset-shadow: rgba(84, 84, 88, 0.3);
--slider-track: rgba(84, 84, 88, 0.5);
--slider-thumb: #98989d;
--slider-thumb-shadow: rgba(152, 152, 157, 0.3);
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
overflow: hidden;
background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}
.app-container {
display: flex;
flex-direction: column;
height: 100vh;
height: 100dvh;
gap: 0;
}
.sidebar {
background: var(--glass-bg);
backdrop-filter: blur(40px) saturate(180%);
-webkit-backdrop-filter: blur(40px) saturate(180%);
border-bottom: 1px solid var(--glass-border);
box-shadow: 0 8px 32px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
padding: 16px;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.sidebar.collapsed {
height: auto !important;
}
.sidebar.collapsed .collapsible-content {
display: none;
}
@media (min-width: 768px) {
.sidebar.collapsed {
width: auto;
padding: 20px;
}
}
.toggle-button {
display: block;
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 12px;
padding: 12px;
margin-bottom: 12px;
cursor: pointer;
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
box-shadow: 0 4px 16px var(--shadow-color);
transition: all 0.2s ease;
text-align: center;
}
.toggle-button:active {
transform: scale(0.98);
}
.dark-mode-toggle {
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 12px;
padding: 10px;
cursor: pointer;
font-size: 20px;
box-shadow: 0 4px 16px var(--shadow-color);
transition: all 0.2s ease;
display: inline-flex;
align-items: center;
justify-content: center;
width: 44px;
height: 44px;
border: none;
}
.dark-mode-toggle:active {
transform: scale(0.95);
}
.header-with-toggle {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
}
.main-viewer {
flex: 1;
overflow-y: auto;
background: var(--viewer-bg);
backdrop-filter: blur(60px) saturate(150%);
-webkit-backdrop-filter: blur(60px) saturate(150%);
padding: 20px;
-webkit-overflow-scrolling: touch;
box-shadow: inset 0 1px 0 var(--inset-shadow);
}
h1 {
font-size: 32px;
font-weight: 700;
color: var(--text-primary);
letter-spacing: -0.5px;
margin-bottom: 0;
}
.subtitle {
font-size: 15px;
color: var(--text-secondary);
font-weight: 400;
line-height: 1.4;
margin-bottom: 16px;
}
.input-card {
background: var(--card-bg);
backdrop-filter: blur(20px) saturate(180%);
-webkit-backdrop-filter: blur(20px) saturate(180%);
border-radius: 16px;
border: 1px solid var(--card-border);
padding: 14px;
margin-bottom: 12px;
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.input-card:active {
transform: scale(0.98);
box-shadow: 0 2px 8px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.input-label {
display: block;
font-weight: 600;
font-size: 13px;
color: var(--text-secondary);
margin-bottom: 8px;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.file-inputs-combined {
display: flex;
flex-direction: column;
gap: 12px;
}
.file-input-row {
display: flex;
align-items: center;
gap: 10px;
padding: 10px;
background: var(--input-bg-start);
border-radius: 10px;
border: 1px dashed var(--card-border);
transition: all 0.2s ease;
cursor: pointer;
}
.file-input-row:active {
background: var(--input-bg-end);
border-color: var(--text-tertiary);
}
.file-input-icon {
font-size: 20px;
flex-shrink: 0;
}
.file-input-wrapper {
flex: 1;
min-width: 0;
}
.file-input-label {
font-size: 11px;
font-weight: 600;
color: var(--text-tertiary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 2px;
}
.file-input-name {
font-size: 13px;
font-weight: 500;
color: var(--text-primary);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
input[type="file"] {
display: none;
}
audio {
width: 100%;
height: 54px;
border-radius: 14px;
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.info-card {
background: linear-gradient(135deg, var(--card-bg) 0%, var(--card-bg) 100%);
backdrop-filter: blur(30px) saturate(180%);
-webkit-backdrop-filter: blur(30px) saturate(180%);
border-radius: 16px;
border: 1px solid var(--card-border);
padding: 16px;
margin: 12px 0;
box-shadow: 0 8px 24px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.zoom-controls {
display: flex;
align-items: center;
justify-content: space-between;
gap: 12px;
}
.zoom-label {
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
flex-shrink: 0;
}
.zoom-buttons {
display: flex;
gap: 8px;
}
.zoom-button {
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 10px;
width: 44px;
height: 44px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
font-size: 20px;
font-weight: 600;
color: var(--text-primary);
box-shadow: 0 2px 8px var(--shadow-color);
transition: all 0.2s ease;
-webkit-user-select: none;
user-select: none;
}
.zoom-button:active {
transform: scale(0.95);
box-shadow: 0 1px 4px var(--shadow-color);
}
.zoom-value {
background: var(--card-bg);
padding: 8px 16px;
border-radius: 10px;
font-weight: 700;
font-size: 15px;
color: var(--text-primary);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
min-width: 60px;
text-align: center;
}
.status-box {
padding: 14px 16px;
border-radius: 14px;
margin: 16px 0;
font-size: 14px;
display: flex;
align-items: center;
gap: 10px;
font-weight: 500;
backdrop-filter: blur(20px) saturate(180%);
-webkit-backdrop-filter: blur(20px) saturate(180%);
border: 1px solid var(--card-border);
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.status-loading {
background: var(--card-bg);
color: var(--text-primary);
}
.status-success {
background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.1) 100%);
color: rgba(30, 132, 73, 1);
}
.status-error {
background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.1) 100%);
color: rgba(215, 0, 21, 1);
}
input[type="range"] {
-webkit-appearance: none;
width: 100%;
height: 6px;
border-radius: 6px;
background: var(--slider-track);
outline: none;
margin: 12px 0;
box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}
input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 24px;
height: 24px;
border-radius: 50%;
background: var(--slider-thumb);
cursor: pointer;
box-shadow: 0 2px 6px var(--slider-thumb-shadow), 0 0 0 3px var(--card-bg);
transition: all 0.2s ease;
}
input[type="range"]::-webkit-slider-thumb:active {
transform: scale(1.1);
box-shadow: 0 3px 10px var(--slider-thumb-shadow), 0 0 0 4px var(--card-bg);
}
input[type="range"]::-moz-range-thumb {
width: 24px;
height: 24px;
border-radius: 50%;
background: var(--slider-thumb);
cursor: pointer;
border: none;
box-shadow: 0 2px 6px var(--slider-thumb-shadow), 0 0 0 3px var(--card-bg);
}
.page-container {
position: relative;
margin: 16px auto;
border-radius: 16px;
overflow: hidden;
box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.5);
touch-action: pan-y;
background: white;
backdrop-filter: blur(40px);
-webkit-backdrop-filter: blur(40px);
transition: transform 0.2s ease;
}
.highlight-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
}
.highlight-overlay.hidden {
display: none;
}
canvas {
display: block;
width: 100%;
height: 100%;
}
.highlight-box {
position: absolute;
background: rgba(255, 214, 10, 0.35);
border-radius: 2px;
transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
box-sizing: border-box;
left: 0;
width: 100%;
padding-top: 6px;
padding-bottom: 6px;
}
.page-badge {
display: inline-flex;
align-items: center;
gap: 8px;
font-size: 14px;
color: var(--text-primary);
margin-bottom: 8px;
font-weight: 500;
}
.page-number {
background: var(--card-bg);
padding: 4px 12px;
border-radius: 8px;
font-weight: 700;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
}
.placeholder {
text-align: center;
padding: 80px 20px;
color: var(--text-tertiary);
}
.placeholder svg {
width: 80px;
height: 80px;
margin: 0 auto 24px;
opacity: 0.3;
filter: drop-shadow(0 4px 8px var(--shadow-color));
}
.placeholder-title {
font-size: 22px;
font-weight: 700;
margin-bottom: 8px;
color: var(--text-secondary);
}
.placeholder-subtitle {
font-size: 15px;
font-weight: 400;
color: var(--text-tertiary);
}
@keyframes liquid-spin {
0% { transform: rotate(0deg) scale(1); }
50% { transform: rotate(180deg) scale(1.05); }
100% { transform: rotate(360deg) scale(1); }
}
.spinner {
width: 20px;
height: 20px;
border: 3px solid rgba(255, 255, 255, 0.3);
border-top-color: currentColor;
border-radius: 50%;
animation: liquid-spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
.speed-label {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
color: var(--text-primary);
}
.speed-value {
background: var(--card-bg);
padding: 4px 14px;
border-radius: 10px;
font-weight: 700;
font-size: 15px;
color: var(--text-primary);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
}
body.dark-mode .speed-value {
color: var(--text-primary);
}
.toggle-switch {
position: relative;
display: inline-block;
width: 51px;
height: 31px;
flex-shrink: 0;
}
.toggle-switch input {
opacity: 0;
width: 0;
height: 0;
}
.toggle-slider {
position: absolute;
cursor: pointer;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: var(--slider-track);
transition: 0.3s;
border-radius: 31px;
box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}
.toggle-slider:before {
position: absolute;
content: "";
height: 23px;
width: 23px;
left: 4px;
bottom: 4px;
background: white;
transition: 0.3s;
border-radius: 50%;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
input:checked + .toggle-slider {
background: #34c759;
}
input:checked + .toggle-slider:before {
transform: translateX(20px);
}
.toggle-row {
display: flex;
justify-content: space-between;
align-items: center;
gap: 12px;
}
.toggle-label-text {
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
flex-grow: 1;
}
@media (min-width: 768px) {
.app-container {
flex-direction: row;
}
.sidebar {
width: 420px;
flex-shrink: 0;
height: 100vh;
height: 100dvh;
border-bottom: none;
border-right: 1px solid var(--glass-border);
box-shadow: 8px 0 32px var(--shadow-color), inset -1px 0 0 var(--inset-shadow);
}
.main-viewer {
padding: 40px;
}
h1 {
font-size: 38px;
}
}
@media (min-width: 768px) and (orientation: landscape) {
.sidebar {
width: 440px;
}
}
.overflow-y-auto {
-webkit-overflow-scrolling: touch;
overscroll-behavior: contain;
scroll-behavior: smooth;
}
label, h1, .subtitle, .status-box, .page-badge {
-webkit-user-select: none;
user-select: none;
}
.main-viewer {
-webkit-user-select: text;
user-select: text;
}
</style>
</head>
<body>
<div class="app-container">
<aside class="sidebar" id="sidebar">
<div class="toggle-button" id="toggle-button">
<span id="toggle-text">‚åÉ Show Controls</span>
</div>
<div style="margin-bottom: 12px;" id="collapsed-audio">
<audio id="audio-player" controls disabled preload="auto"></audio>
<button class="toggle-button" id="test-play-audio" style="margin-top: 8px; padding: 8px; font-size: 13px; background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.1) 100%); color: rgba(30, 132, 73, 1);">
‚ñ∂Ô∏è Test Play Audio
</button>
<button class="toggle-button" id="force-load-audio" style="display: none; margin-top: 8px; padding: 8px; font-size: 13px; background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.1) 100%); color: rgba(30, 132, 73, 1);">
üîÑ Force Load Audio
</button>
</div>
<div class="collapsible-content">
<div class="header-with-toggle">
<h1>PDF Audio Player</h1>
<div style="display: flex; gap: 8px;">
<button class="dark-mode-toggle" id="debug-mode-toggle" title="Toggle Debug Console">
<span id="debug-icon">üêõ</span>
</button>
<button class="dark-mode-toggle" id="dark-mode-toggle" title="Toggle Dark Mode">
<span id="theme-icon">üåô</span>
</button>
</div>
</div>
<p class="subtitle">Upload files for synchronized playback with highlighting</p>
<div style="text-align: center; margin: -8px 0 12px 0;">
<span id="app-version" style="font-size: 11px; color: var(--text-tertiary); font-weight: 600; background: var(--card-bg); padding: 4px 10px; border-radius: 8px; border: 1px solid var(--card-border);">Loading...</span>
</div>
<div class="input-card">
<label class="input-label">Upload Files</label>
<div class="file-inputs-combined">
<label class="file-input-row" for="pdf-file">
<span class="file-input-icon">üìÑ</span>
<div class="file-input-wrapper">
<div class="file-input-label">PDF Document</div>
<div class="file-input-name" id="pdf-file-name">No file selected</div>
</div>
</label>
<input type="file" id="pdf-file" accept=".pdf,application/pdf">
<label class="file-input-row" for="mp3-file">
<span class="file-input-icon">üéµ</span>
<div class="file-input-wrapper">
<div class="file-input-label">Audio File</div>
<div class="file-input-name" id="mp3-file-name">No file selected</div>
</div>
</label>
<input type="file" id="mp3-file" accept=".mp3,audio/mpeg,audio/*">
<label class="file-input-row" for="json-file">
<span class="file-input-icon">üìã</span>
<div class="file-input-wrapper">
<div class="file-input-label">JSON Manifest</div>
<div class="file-input-name" id="json-file-name">No file selected</div>
</div>
</label>
<input type="file" id="json-file" accept=".json,application/json">
</div>
</div>
<div id="status-box" class="status-box status-loading" style="display: none;">
<div id="loading-spinner" class="spinner"></div>
<span id="status-message">Loading...</span>
</div>
<div class="info-card">
<div class="speed-label">
<span style="font-weight: 600; font-size: 15px;">Playback Speed</span>
<span id="speed-value" class="speed-value">1.0x</span>
</div>
<input type="range" id="speed-slider" min="0.5" max="2.0" step="0.1" value="1.0">
<div class="toggle-row" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<span class="toggle-label-text">Show Highlighter</span>
<label class="toggle-switch">
<input type="checkbox" id="highlighter-toggle" checked>
<span class="toggle-slider"></span>
</label>
</div>
<div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<div class="speed-label">
<span style="font-weight: 600; font-size: 15px;">Highlight Offset</span>
<span id="offset-value" class="speed-value">0%</span>
</div>
<input type="range" id="offset-slider" min="-15" max="15" step="1" value="0">
</div>
<div class="zoom-controls" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<span class="zoom-label">PDF Zoom</span>
<div style="display: flex; align-items: center; gap: 8px;">
<span id="zoom-value" class="zoom-value">100%</span>
<div class="zoom-buttons">
<button class="zoom-button" id="zoom-out" title="Zoom Out">‚àí</button>
<button class="zoom-button" id="zoom-in" title="Zoom In">+</button>
</div>
</div>
</div>
</div>
<div class="info-card">
<div class="page-badge" id="audio-page-display">
üìñ Reading: <span class="page-number">-</span>
</div>
<div class="page-badge" id="user-page-display">
üëÅÔ∏è Viewing: <span class="page-number">-</span>
</div>
</div>
<div class="input-card">
<button class="toggle-button" id="reset-data-button" style="background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.1) 100%); color: rgba(215, 0, 21, 1); margin-bottom: 0;">
üóëÔ∏è Clear All Cached Data
</button>
</div>
<div class="input-card" id="debug-console-card" style="display: none;">
<label class="input-label">Debug Console</label>
<div id="debug-console" style="font-family: monospace; font-size: 11px; max-height: 200px; overflow-y: auto; background: var(--input-bg-start); padding: 10px; border-radius: 8px; color: var(--text-primary);"></div>
<div style="display: flex; gap: 8px; margin-top: 8px;">
<button class="toggle-button" id="share-logs-button" style="flex: 1; padding: 8px; font-size: 12px; background: linear-gradient(135deg, rgba(0, 122, 255, 0.15) 0%, rgba(0, 122, 255, 0.1) 100%); color: rgba(0, 122, 255, 1);">
üì§ Share Logs
</button>
<button class="toggle-button" id="clear-console-button" style="flex: 1; padding: 8px; font-size: 12px;">
üóëÔ∏è Clear
</button>
</div>
</div>
</div>
</aside>
<main class="main-viewer" id="pdf-viewer">
<div id="pdf-container">
<div id="viewer-placeholder" class="placeholder">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
</svg>
<div class="placeholder-title">No Document Loaded</div>
<div class="placeholder-subtitle">Upload a PDF file to begin</div>
</div>
</div>
</main>
</div>
<script>
let pdfDoc = null;
let manifest = null;
let pageViewports = {};
let audioPlayer = document.getElementById('audio-player');
let pdfContainer = document.getElementById('pdf-container');
let viewerPlaceholder = document.getElementById('viewer-placeholder');
let statusBox = document.getElementById('status-box');
let statusMessage = document.getElementById('status-message');
let loadingSpinner = document.getElementById('loading-spinner');
let audioPageDisplay = document.getElementById('audio-page-display');
let userPageDisplay = document.getElementById('user-page-display');
let speedSlider = document.getElementById('speed-slider');
let speedValueDisplay = document.getElementById('speed-value');
let highlighterToggle = document.getElementById('highlighter-toggle');
let offsetSlider = document.getElementById('offset-slider');
let offsetValueDisplay = document.getElementById('offset-value');
let currentHighlight = null;
let currentHighlightSentence = null;
let currentAudioPage = null;
let currentUserPage = null;
let pdfScale = 1.5;
let fileTracker = { pdf: false, mp3: false, json: false };
let intersectionObserver = null;
let zoomLevel = 100;
let highlighterEnabled = true;
let highlightOffset = 0;
const zoomStep = 25;
const minZoom = 50;
const maxZoom = 200;
const zoomInButton = document.getElementById('zoom-in');
const zoomOutButton = document.getElementById('zoom-out');
const zoomValueDisplay = document.getElementById('zoom-value');
const forceLoadAudioButton = document.getElementById('force-load-audio');
const testPlayAudioButton = document.getElementById('test-play-audio');
let currentMp3File = null; // Store the current MP3 file for manual reloading
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

// Setup audio event listeners early (on page load)
let currentTimeMonitor = null;

function setupAudioEventListeners() {
  if (audioPlayer.hasAttribute('data-listeners-added')) return;
  audioPlayer.setAttribute('data-listeners-added', 'true');

  audioPlayer.addEventListener('loadstart', () => console.log('üéµ Audio: loadstart'));
  audioPlayer.addEventListener('loadedmetadata', () => {
    console.log('‚úÖ Audio: loadedmetadata');
    console.log('   Duration:', audioPlayer.duration);
    console.log('   ReadyState:', audioPlayer.readyState);
    console.log('   NetworkState:', audioPlayer.networkState);
    console.log('   Paused:', audioPlayer.paused);
    console.log('   Disabled:', audioPlayer.disabled);
  });
  audioPlayer.addEventListener('loadeddata', () => console.log('‚úÖ Audio: loadeddata'));
  audioPlayer.addEventListener('canplay', () => console.log('‚úÖ Audio: canplay'));
  audioPlayer.addEventListener('canplaythrough', () => console.log('‚úÖ Audio: canplaythrough'));
  audioPlayer.addEventListener('play', () => {
    console.log('‚ñ∂Ô∏è Audio: play event');
    // Start monitoring currentTime every 100ms when playing
    if (currentTimeMonitor) clearInterval(currentTimeMonitor);
    currentTimeMonitor = setInterval(() => {
      console.log(`‚è±Ô∏è CurrentTime: ${audioPlayer.currentTime.toFixed(3)}s | Paused: ${audioPlayer.paused}`);
    }, 100);
  });
  audioPlayer.addEventListener('playing', () => console.log('‚ñ∂Ô∏è Audio: playing'));
  audioPlayer.addEventListener('pause', () => {
    console.log('‚è∏Ô∏è Audio: pause event');
    // Stop monitoring when paused
    if (currentTimeMonitor) {
      clearInterval(currentTimeMonitor);
      currentTimeMonitor = null;
    }
  });
  audioPlayer.addEventListener('ended', () => {
    console.log('üèÅ Audio: ended');
    if (currentTimeMonitor) {
      clearInterval(currentTimeMonitor);
      currentTimeMonitor = null;
    }
  });
  audioPlayer.addEventListener('error', (e) => {
    console.error('‚ùå Audio Error:', {
      error: audioPlayer.error,
      code: audioPlayer.error?.code,
      message: audioPlayer.error?.message,
      event: e
    });
    if (currentTimeMonitor) {
      clearInterval(currentTimeMonitor);
      currentTimeMonitor = null;
    }
  });
  audioPlayer.addEventListener('stalled', () => console.warn('‚ö†Ô∏è Audio: stalled'));
  audioPlayer.addEventListener('suspend', () => console.warn('‚ö†Ô∏è Audio: suspend'));
  audioPlayer.addEventListener('abort', () => console.warn('‚ö†Ô∏è Audio: abort'));
}

// Call it immediately
setupAudioEventListeners();

const darkModeToggle = document.getElementById('dark-mode-toggle');
const themeIcon = document.getElementById('theme-icon');
const currentTheme = localStorage.getItem('theme');
if (currentTheme === 'dark') {
document.body.classList.add('dark-mode');
themeIcon.textContent = '‚òÄÔ∏è';
}
darkModeToggle.addEventListener('click', () => {
document.body.classList.toggle('dark-mode');
const isDark = document.body.classList.contains('dark-mode');
themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
localStorage.setItem('theme', isDark ? 'dark' : 'light');
});
highlighterToggle.addEventListener('change', (e) => {
highlighterEnabled = e.target.checked;
const overlays = document.querySelectorAll('.highlight-overlay');
overlays.forEach(overlay => {
if (highlighterEnabled) {
overlay.classList.remove('hidden');
} else {
overlay.classList.add('hidden');
}
});
localStorage.setItem('highlighterEnabled', highlighterEnabled ? 'true' : 'false');
});
const savedHighlighterState = localStorage.getItem('highlighterEnabled');
if (savedHighlighterState === 'false') {
highlighterEnabled = false;
highlighterToggle.checked = false;
}
offsetSlider.addEventListener('input', (e) => {
highlightOffset = parseInt(e.target.value, 10);
offsetValueDisplay.textContent = `${highlightOffset > 0 ? '+' : ''}${highlightOffset}%`;
localStorage.setItem('highlightOffset', highlightOffset);
if (manifest && currentHighlightSentence !== null && highlighterEnabled) {
const currentSentence = manifest.find(s => s.i === currentHighlightSentence);
if (currentSentence) {
drawHighlight(currentSentence);
}
}
});
const savedOffset = localStorage.getItem('highlightOffset');
if (savedOffset !== null) {
highlightOffset = parseInt(savedOffset, 10);
offsetSlider.value = highlightOffset;
offsetValueDisplay.textContent = `${highlightOffset > 0 ? '+' : ''}${highlightOffset}%`;
}
zoomInButton.addEventListener('click', () => {
if (zoomLevel < maxZoom) {
zoomLevel += zoomStep;
updateZoom();
}
});
zoomOutButton.addEventListener('click', () => {
if (zoomLevel > minZoom) {
zoomLevel -= zoomStep;
updateZoom();
}
});
function updateZoom() {
zoomValueDisplay.textContent = `${zoomLevel}%`;
const containers = document.querySelectorAll('.page-container');
const zoomScale = zoomLevel / 100;
containers.forEach((container, index) => {
container.style.transform = `scale(${zoomScale})`;
container.style.transformOrigin = 'top center';
if (index < containers.length - 1) {
const originalHeight = container.offsetHeight;
const scaledHeight = originalHeight * zoomScale;
const marginAdjustment = originalHeight - scaledHeight;
container.style.marginBottom = `${16 - marginAdjustment}px`;
}
});
}
document.getElementById('pdf-file').addEventListener('change', handlePdfUpload);
document.getElementById('mp3-file').addEventListener('change', handleMp3Upload);
document.getElementById('json-file').addEventListener('change', handleJsonUpload);
audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
speedSlider.addEventListener('input', handleSpeedChange);
const toggleButton = document.getElementById('toggle-button');
const toggleText = document.getElementById('toggle-text');
const sidebar = document.getElementById('sidebar');
let isCollapsed = false;
if (toggleButton) {
toggleButton.addEventListener('click', () => {
isCollapsed = !isCollapsed;
if (isCollapsed) {
sidebar.classList.add('collapsed');
toggleText.textContent = '‚åÑ Hide Controls';
} else {
sidebar.classList.remove('collapsed');
toggleText.textContent = '‚åÉ Show Controls';
}
});
}
async function handlePdfUpload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('pdf-file-name').textContent = file.name;
viewerPlaceholder.style.display = 'none';
showStatus('Rendering PDF pages...', true);
pageViewports = {};
currentUserPage = null;
currentAudioPage = null;
if (intersectionObserver) intersectionObserver.disconnect();

// v18-simple: NO CACHING
console.log('üìÑ Loading PDF (no caching)...');

const fileReader = new FileReader();
fileReader.onload = function() {
const typedarray = new Uint8Array(this.result);
const loadingTask = pdfjsLib.getDocument(typedarray);
loadingTask.promise.then(pdf => {
pdfDoc = pdf;
fileTracker.pdf = true;
pdfContainer.innerHTML = '';
renderAllPages();
}).catch(err => {
showStatus('Error loading PDF: ' + err.message, false, true);
console.error('PDF Load Error:', err);
});
};
fileReader.readAsArrayBuffer(file);
}
async function handleMp3Upload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('mp3-file-name').textContent = file.name;

console.log('üìÅ MP3 File Details:', {
  name: file.name,
  size: file.size,
  type: file.type,
  lastModified: file.lastModified
});

console.log('üåê Network status:', navigator.onLine ? 'ONLINE' : 'OFFLINE');

// CRITICAL: iOS Safari offline blob URL bug
// When offline, blob URLs work for loading metadata but decoder gets stuck at 0:00
// Solution: Use data URL when offline
if (!navigator.onLine) {
  console.log('‚ö†Ô∏è OFFLINE detected - using data URL for iOS Safari compatibility');
  console.log('üìä File size:', (file.size / 1024 / 1024).toFixed(2), 'MB');

  try {
    const dataURL = await loadMp3AsDataURL(file);
    console.log('‚úÖ Data URL created, length:', dataURL.length);

    if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
      URL.revokeObjectURL(audioPlayer.src);
    }

    audioPlayer.src = dataURL;
    audioPlayer.load();
    console.log('üéµ Audio player src set to data URL (offline mode)');
  } catch (err) {
    console.error('‚ùå Data URL conversion failed:', err);
    // Fallback to blob even though it won't work offline
    const url = URL.createObjectURL(file);
    audioPlayer.src = url;
    audioPlayer.load();
  }
} else {
  // Online: use blob URL (faster, less memory)
  console.log('‚úÖ ONLINE - using blob URL');
  if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
    URL.revokeObjectURL(audioPlayer.src);
  }
  const url = URL.createObjectURL(file);
  console.log('‚úÖ Blob URL created:', url);
  audioPlayer.src = url;
  audioPlayer.load();
}

console.log('üéµ Audio player ready state:', audioPlayer.readyState);
console.log('üéµ Audio player network state:', audioPlayer.networkState);

fileTracker.mp3 = true;
currentMp3File = file;
checkAllFilesLoaded();
}
async function handleJsonUpload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('json-file-name').textContent = file.name;

// v18-simple: NO CACHING
console.log('üìã Loading JSON (no caching)...');

const fileReader = new FileReader();
fileReader.onload = function() {
try {
const data = JSON.parse(this.result);
if (data && data.sentences && Array.isArray(data.sentences)) {
manifest = data.sentences;
fileTracker.json = true;
checkAllFilesLoaded();
} else {
showStatus('Invalid JSON: Missing "sentences" array', false, true);
}
} catch (err) {
showStatus('Error parsing JSON file', false, true);
console.error('JSON Parse Error:', err);
}
};
fileReader.readAsText(file);
}
function handleSpeedChange(e) {
const speed = parseFloat(e.target.value);
if (audioPlayer && !isNaN(speed)) {
audioPlayer.playbackRate = speed;
speedValueDisplay.textContent = `${speed.toFixed(1)}x`;
}
}
function checkAllFilesLoaded() {
if (fileTracker.pdf && fileTracker.mp3 && fileTracker.json) {
showStatus('Ready to play!', false, false);
audioPlayer.disabled = false;
const initialSpeed = parseFloat(speedSlider.value) || 1.0;
audioPlayer.playbackRate = initialSpeed;
speedValueDisplay.textContent = `${initialSpeed.toFixed(1)}x`;
updatePageDisplays();
setTimeout(() => {
statusBox.style.display = 'none';
}, 2000);
} else {
let missing = [];
if (!fileTracker.pdf) missing.push('PDF');
if (!fileTracker.mp3) missing.push('MP3');
if (!fileTracker.json) missing.push('JSON');
showStatus('Waiting for: ' + missing.join(', '), true, false);
currentAudioPage = null;
currentUserPage = null;
updatePageDisplays();
}
}
async function renderAllPages() {
if (!pdfDoc) return;
const numPages = pdfDoc.numPages;
showStatus(`Rendering ${numPages} page${numPages > 1 ? 's' : ''}...`, true, false);
for (let i = 1; i <= numPages; i++) {
const page = await pdfDoc.getPage(i);
pageViewports[i] = page.getViewport({ scale: 1.0 });
const viewport = page.getViewport({ scale: pdfScale });
const pageContainer = document.createElement('div');
pageContainer.id = `page-container-${i}`;
pageContainer.className = 'page-container';
pageContainer.style.width = `${viewport.width}px`;
pageContainer.style.height = `${viewport.height}px`;
pageContainer.dataset.pageNumber = i;
const canvas = document.createElement('canvas');
canvas.id = `pdf-canvas-${i}`;
canvas.width = viewport.width;
canvas.height = viewport.height;
const highlightOverlay = document.createElement('div');
highlightOverlay.id = `highlight-overlay-${i}`;
highlightOverlay.className = 'highlight-overlay';
if (!highlighterEnabled) {
highlightOverlay.classList.add('hidden');
}
pageContainer.appendChild(canvas);
pageContainer.appendChild(highlightOverlay);
pdfContainer.appendChild(pageContainer);
const renderContext = {
canvasContext: canvas.getContext('2d'),
viewport: viewport
};
try {
await page.render(renderContext).promise;
} catch (err) {
console.error(`Error rendering page ${i}:`, err);
}
}
setupIntersectionObserver();
checkAllFilesLoaded();
}
function setupIntersectionObserver() {
const options = {
root: document.getElementById('pdf-viewer'),
rootMargin: '0px',
threshold: 0.5
};
intersectionObserver = new IntersectionObserver(handleIntersection, options);
document.querySelectorAll('.page-container').forEach(pageEl => {
intersectionObserver.observe(pageEl);
});
}
function handleIntersection(entries) {
entries.forEach(entry => {
if (entry.isIntersecting) {
const newPage = parseInt(entry.target.dataset.pageNumber, 10);
if (newPage !== currentUserPage) {
currentUserPage = newPage;
updatePageDisplays();
}
}
});
}
function handleTimeUpdate() {
if (!manifest || audioPlayer.paused) return;
const currentTime = audioPlayer.currentTime;
const sentence = findSentenceForTime(currentTime);
if (sentence) {
const newPage = sentence.location?.page_number;
if (newPage && newPage !== currentAudioPage) {
currentAudioPage = newPage;
updatePageDisplays();
}
if (sentence.i !== currentHighlightSentence) {
currentHighlightSentence = sentence.i;
if (highlighterEnabled) {
drawHighlight(sentence);
}
}
}
}
function findSentenceForTime(time) {
return manifest.find(s => time >= s.start && time < s.end);
}
function drawHighlight(sentence) {
if (currentHighlight) {
currentHighlight.remove();
currentHighlight = null;
}
const loc = sentence.location;
if (!loc || !loc.page_number || !loc.points) return;
const coords = loc.points;
if (!Array.isArray(coords) || coords.length < 3 ||
!Array.isArray(coords[0]) || coords[0].length < 2 ||
!Array.isArray(coords[2]) || coords[2].length < 2) return;
const y_min_raw = coords[0][1];
const y_max_raw = coords[2][1];
if (typeof y_min_raw !== 'number' || typeof y_max_raw !== 'number' || y_max_raw <= y_min_raw) return;
const pageNum = loc.page_number;
const overlay = document.getElementById(`highlight-overlay-${pageNum}`);
const canvas = document.getElementById(`pdf-canvas-${pageNum}`);
const pageViewport = pageViewports[pageNum];
if (!overlay || !canvas || !pageViewport) return;
// Use actual PDF page height (at scale 1.0) for correct normalization
// Coordinates from PyMuPDF/unstructured are in PDF points (scale 1.0)
const pdfPageHeight = pageViewport.height;
const canvasHeight = canvas.height;
// Normalize using actual page height, then scale to canvas
const norm_y_min = y_min_raw / pdfPageHeight;
const norm_y_max = y_max_raw / pdfPageHeight;
const clamped_norm_y_min = Math.max(0, Math.min(1, norm_y_min));
const clamped_norm_y_max = Math.max(0, Math.min(1, norm_y_max));
let final_y = clamped_norm_y_min * canvasHeight;
const final_height = (clamped_norm_y_max - clamped_norm_y_min) * canvasHeight;
const offsetPixels = (highlightOffset / 100) * canvasHeight;
final_y += offsetPixels;
final_y = Math.max(0, Math.min(canvasHeight - final_height, final_y));
const box = document.createElement('div');
box.className = 'highlight-box';
box.style.top = `${final_y}px`;
box.style.height = `${final_height}px`;
overlay.appendChild(box);
currentHighlight = box;
}
function showStatus(message, isLoading, isError) {
statusBox.style.display = 'flex';
statusMessage.textContent = message;
loadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
if (isError) {
statusBox.className = 'status-box status-error';
} else if (isLoading) {
statusBox.className = 'status-box status-loading';
} else {
statusBox.className = 'status-box status-success';
}
}
function updatePageDisplays() {
const totalPages = pdfDoc ? pdfDoc.numPages : '-';
const reading = currentAudioPage ?? '-';
const viewing = currentUserPage ?? '-';
audioPageDisplay.innerHTML = `üìñ Reading: <span class="page-number">${reading} / ${totalPages}</span>`;
userPageDisplay.innerHTML = `üëÅÔ∏è Viewing: <span class="page-number">${viewing} / ${totalPages}</span>`;
}
let lastTouchEnd = 0;
document.addEventListener('touchend', (event) => {
const now = Date.now();
if (now - lastTouchEnd <= 300) {
event.preventDefault();
}
lastTouchEnd = now;
}, false);
document.addEventListener('gesturestart', (e) => e.preventDefault());
document.addEventListener('gesturechange', (e) => e.preventDefault());
document.addEventListener('gestureend', (e) => e.preventDefault());
let orientationChangeTimeout;
window.addEventListener('orientationchange', () => {
clearTimeout(orientationChangeTimeout);
orientationChangeTimeout = setTimeout(() => {
console.log('Orientation changed');
}, 100);
});
const APP_VERSION = 'v19';
console.log(`‚úÖ PDF Audio Player ${APP_VERSION} loaded with highlighter toggle!`);

// Display version in UI
document.getElementById('app-version').textContent = APP_VERSION;

// ========================================
// On-Screen Debug Console for Mobile
// ========================================

const debugConsoleElement = document.getElementById('debug-console');
const debugConsoleCard = document.getElementById('debug-console-card');
let debugMode = localStorage.getItem('debugMode') === 'true';
let logHistory = []; // Store all logs for sharing

// Show debug console if enabled
if (debugMode) {
  debugConsoleCard.style.display = 'block';
}

// Function to add log to on-screen console
function debugLog(message, type = 'log') {
  const timestamp = new Date().toLocaleTimeString();

  // Always store in history for sharing
  logHistory.push({
    timestamp: timestamp,
    type: type,
    message: message
  });

  if (!debugMode) return;

  const colors = {
    log: 'var(--text-primary)',
    error: '#ff3b30',
    warn: '#ff9500',
    success: '#34c759'
  };

  const logEntry = document.createElement('div');
  logEntry.style.color = colors[type] || colors.log;
  logEntry.style.marginBottom = '4px';
  logEntry.style.borderBottom = '1px solid var(--card-border)';
  logEntry.style.paddingBottom = '4px';
  logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;

  debugConsoleElement.appendChild(logEntry);
  debugConsoleElement.scrollTop = debugConsoleElement.scrollHeight;
}

// Override console methods to show in on-screen console
const originalLog = console.log;
const originalError = console.error;
const originalWarn = console.warn;

console.log = function(...args) {
  originalLog.apply(console, args);
  const message = args.map(arg =>
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  debugLog(message, 'log');
};

console.error = function(...args) {
  originalError.apply(console, args);
  const message = args.map(arg =>
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  debugLog('ERROR: ' + message, 'error');
};

console.warn = function(...args) {
  originalWarn.apply(console, args);
  const message = args.map(arg =>
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  debugLog('WARN: ' + message, 'warn');
};

// Toggle debug mode with button
const debugModeToggle = document.getElementById('debug-mode-toggle');
const debugIcon = document.getElementById('debug-icon');

debugModeToggle.addEventListener('click', () => {
  debugMode = !debugMode;
  localStorage.setItem('debugMode', debugMode);
  debugConsoleCard.style.display = debugMode ? 'block' : 'none';

  if (debugMode) {
    debugIcon.textContent = 'üü¢';
    debugLog('üêõ Debug mode enabled', 'success');
    showStatus('Debug mode enabled! Console visible.', false, false);
  } else {
    debugIcon.textContent = 'üêõ';
    showStatus('Debug mode disabled.', false, false);
  }

  setTimeout(() => {
    statusBox.style.display = 'none';
  }, 2000);
});

// Share logs button
document.getElementById('share-logs-button').addEventListener('click', async () => {
  console.log('üì§ Preparing logs for sharing...');

  try {
    // Format logs as text
    const logsText = logHistory.map(log =>
      `[${log.timestamp}] ${log.type.toUpperCase()}: ${log.message}`
    ).join('\n');

    const fullReport = `PDF Audio Player - Debug Logs
App Version: ${APP_VERSION}
Generated: ${new Date().toLocaleString()}
User Agent: ${navigator.userAgent}
Online: ${navigator.onLine}

=== LOGS ===
${logsText}

=== END OF LOGS ===`;

    // Try Web Share API first (for AirDrop on iOS/Mac)
    if (navigator.share && navigator.canShare) {
      const file = new File([fullReport], 'debug-logs.txt', { type: 'text/plain' });

      if (navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: 'PDF Audio Player Debug Logs',
          text: 'Debug logs from PDF Audio Player'
        });
        console.log('‚úÖ Logs shared successfully!');
        return;
      }
    }

    // Fallback: Download as file
    const blob = new Blob([fullReport], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `debug-logs-${Date.now()}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log('‚úÖ Logs downloaded as file');
    showStatus('Logs downloaded! Check your downloads.', false, false);
    setTimeout(() => statusBox.style.display = 'none', 3000);

  } catch (err) {
    console.error('‚ùå Error sharing logs:', err);
    showStatus('Failed to share logs: ' + err.message, false, true);
  }
});

// Clear console button
document.getElementById('clear-console-button').addEventListener('click', () => {
  debugConsoleElement.innerHTML = '';
  logHistory = [];
  debugLog('Console cleared', 'log');
});

// ========================================
// Cache API Storage for Offline Support (PRIMARY)
// ========================================

const USER_FILES_CACHE = 'pdf-audio-player-user-files-v1';

// Save file to Cache API
async function saveFileToCache(type, file) {
  try {
    console.log(`üíæ Saving ${type} to Cache API:`, {
      name: file.name,
      size: file.size,
      type: file.type
    });

    const cache = await caches.open(USER_FILES_CACHE);

    // Create a unique URL for this file type
    const fileUrl = `/cached-files/${type}`;

    // Create a Response object with the file
    const response = new Response(file, {
      headers: {
        'Content-Type': file.type,
        'X-File-Name': file.name,
        'X-File-Size': file.size.toString(),
        'X-File-Modified': file.lastModified.toString()
      }
    });

    await cache.put(fileUrl, response);
    console.log(`‚úÖ Saved ${type} to Cache API:`, file.name, 'Size:', file.size, 'bytes');
    return true;
  } catch (err) {
    console.error(`‚ùå Error saving ${type} to Cache API:`, err);
    return false;
  }
}

// Load file from Cache API
async function loadFileFromCache(type) {
  try {
    const cache = await caches.open(USER_FILES_CACHE);
    const fileUrl = `/cached-files/${type}`;
    const response = await cache.match(fileUrl);

    if (!response) {
      console.log(`‚ÑπÔ∏è No cached ${type} found`);
      return null;
    }

    const blob = await response.blob();
    const fileName = response.headers.get('X-File-Name') || `cached-${type}`;
    const fileSize = parseInt(response.headers.get('X-File-Size') || '0');
    const lastModified = parseInt(response.headers.get('X-File-Modified') || Date.now());

    console.log(`‚úÖ Loaded ${type} from Cache API:`, fileName, 'Size:', fileSize, 'bytes');

    // Reconstruct File object
    const file = new File([blob], fileName, {
      type: blob.type,
      lastModified: lastModified
    });

    return {
      file: file,
      name: fileName,
      size: fileSize
    };
  } catch (err) {
    console.error(`‚ùå Error loading ${type} from Cache API:`, err);
    return null;
  }
}

// Clear all cached files
async function clearCachedFiles() {
  try {
    const deleted = await caches.delete(USER_FILES_CACHE);
    if (deleted) {
      console.log('‚úÖ Cached files cleared');
    }
    return deleted;
  } catch (err) {
    console.error('‚ùå Error clearing cached files:', err);
    return false;
  }
}

// ========================================
// IndexedDB Storage (FALLBACK)
// ========================================

const DB_NAME = 'pdfAudioPlayerDB';
const DB_VERSION = 1;
const STORE_NAME = 'userFiles';

// Open or create IndexedDB
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      console.error('‚ùå IndexedDB failed to open:', request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      console.log('‚úÖ IndexedDB opened successfully');
      resolve(request.result);
    };

    request.onupgradeneeded = (event) => {
      console.log('üîß IndexedDB upgrade needed, creating object store...');
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'type' });
        console.log('‚úÖ Object store created');
      }
    };
  });
}

// Save file to IndexedDB as ArrayBuffer (preserves binary data)
async function saveFileToIndexedDB(type, file) {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    console.log(`üíæ Saving ${type} to IndexedDB:`, {
      name: file.name,
      size: file.size,
      type: file.type,
      isFile: file instanceof File,
      isBlob: file instanceof Blob
    });

    // Convert file to ArrayBuffer to preserve binary data
    console.log(`üîÑ Converting ${type} to ArrayBuffer...`);
    const arrayBuffer = await file.arrayBuffer();
    console.log(`‚úÖ ArrayBuffer created, size:`, arrayBuffer.byteLength, 'bytes');

    const putRequest = store.put({
      type: type,
      arrayBuffer: arrayBuffer,
      name: file.name,
      size: file.size,
      mimeType: file.type,
      lastModified: file.lastModified
    });

    return new Promise((resolve, reject) => {
      putRequest.onsuccess = () => {
        console.log(`‚úÖ Saved ${type} file to IndexedDB:`, file.name, 'Size:', file.size, 'bytes');
        resolve();
      };
      putRequest.onerror = () => {
        console.error(`‚ùå Put request failed for ${type}:`, putRequest.error);
        reject(putRequest.error);
      };
      tx.onerror = () => {
        console.error(`‚ùå Transaction failed for ${type}:`, tx.error);
        reject(tx.error);
      };
    });
  } catch (err) {
    console.error(`‚ùå Error saving ${type} to IndexedDB:`, err);
    throw err;
  }
}

// Load file from IndexedDB and reconstruct as Blob
async function loadFileFromIndexedDB(type) {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);

    return new Promise((resolve, reject) => {
      const request = store.get(type);
      request.onsuccess = () => {
        if (request.result) {
          const data = request.result;
          console.log(`‚úÖ Loaded ${type} from IndexedDB:`, data.name, 'Size:', data.size);

          // Reconstruct File from ArrayBuffer
          if (data.arrayBuffer) {
            console.log(`üîÑ Reconstructing ${type} from ArrayBuffer (${data.arrayBuffer.byteLength} bytes)...`);
            const blob = new Blob([data.arrayBuffer], { type: data.mimeType });
            const file = new File([blob], data.name, {
              type: data.mimeType,
              lastModified: data.lastModified
            });
            console.log(`‚úÖ Reconstructed File:`, {
              name: file.name,
              size: file.size,
              type: file.type
            });
            resolve({
              file: file,
              name: data.name,
              size: data.size
            });
          } else {
            // Fallback for old format (if exists)
            console.log(`‚ö†Ô∏è Old format detected, using file directly`);
            resolve(data);
          }
        } else {
          resolve(null);
        }
      };
      request.onerror = () => reject(request.error);
    });
  } catch (err) {
    console.error(`‚ùå Error loading ${type} from IndexedDB:`, err);
    return null;
  }
}

// Clear all data from IndexedDB
async function clearAllIndexedDBData() {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    await store.clear();
    console.log('‚úÖ All IndexedDB data cleared');

    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  } catch (err) {
    console.error('‚ùå Error clearing IndexedDB:', err);
    throw err;
  }
}

// Check storage usage
async function checkStorageUsage() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    const usedMB = (estimate.usage / 1024 / 1024).toFixed(2);
    const quotaMB = (estimate.quota / 1024 / 1024).toFixed(2);
    console.log(`üíæ Storage: ${usedMB} MB used of ${quotaMB} MB available`);
    return { used: usedMB, quota: quotaMB };
  }
  return null;
}

// Restore files from Cache on app startup
async function restoreFilesFromCache() {
  console.log(`üîÑ Checking for cached files... (App version: ${APP_VERSION})`);

  try {
    // Try Cache API first, fallback to IndexedDB
    let pdfData = await loadFileFromCache('pdf');
    if (!pdfData) {
      console.log('‚ÑπÔ∏è Trying IndexedDB fallback for PDF...');
      pdfData = await loadFileFromIndexedDB('pdf');
    }
    if (pdfData && pdfData.file) {
      document.getElementById('pdf-file-name').textContent = pdfData.name;
      viewerPlaceholder.style.display = 'none';
      showStatus('Restoring PDF from cache...', true);

      const fileReader = new FileReader();
      fileReader.onload = function() {
        const typedarray = new Uint8Array(this.result);
        const loadingTask = pdfjsLib.getDocument(typedarray);
        loadingTask.promise.then(pdf => {
          pdfDoc = pdf;
          fileTracker.pdf = true;
          pdfContainer.innerHTML = '';
          renderAllPages();
          console.log('‚úÖ PDF restored from cache');
        }).catch(err => {
          showStatus('Error loading cached PDF: ' + err.message, false, true);
          console.error('PDF Load Error:', err);
        });
      };
      fileReader.readAsArrayBuffer(pdfData.file);
    }

    // Restore MP3
    let mp3Data = await loadFileFromCache('mp3');
    if (!mp3Data) {
      console.log('‚ÑπÔ∏è Trying IndexedDB fallback for MP3...');
      mp3Data = await loadFileFromIndexedDB('mp3');
    }
    if (mp3Data && mp3Data.file) {
      document.getElementById('mp3-file-name').textContent = mp3Data.name;

      console.log('üìÅ Restoring MP3 from cache:', {
        name: mp3Data.name,
        size: mp3Data.size,
        type: mp3Data.file.type,
        isFile: mp3Data.file instanceof File,
        isBlob: mp3Data.file instanceof Blob
      });

      // Store file for manual reload
      currentMp3File = mp3Data.file;

      // Use data URL for iOS Safari PWA compatibility
      console.log('üîÑ Converting cached MP3 to data URL...');
      console.log('üìä File size:', (mp3Data.file.size / 1024 / 1024).toFixed(2), 'MB');

      try {
        const dataURL = await loadMp3AsDataURL(mp3Data.file);
        console.log('‚úÖ Data URL created, length:', dataURL.length);

        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }

        audioPlayer.src = dataURL;
        audioPlayer.load();
        console.log('üéµ Audio player src set to data URL');
        console.log('üéµ Audio player ready state:', audioPlayer.readyState);
        console.log('üéµ Audio player network state:', audioPlayer.networkState);

        fileTracker.mp3 = true;
        console.log('‚úÖ MP3 restored from cache with data URL');
        checkAllFilesLoaded();
      } catch (err) {
        console.error('‚ùå Data URL conversion failed:', err);
        // Fallback to blob URL
        console.warn('‚ö†Ô∏è Falling back to blob URL...');
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }
        const url = URL.createObjectURL(mp3Data.file);
        audioPlayer.src = url;
        audioPlayer.load();
        fileTracker.mp3 = true;
        checkAllFilesLoaded();
      }
    }

    // Restore JSON
    let jsonData = await loadFileFromCache('json');
    if (!jsonData) {
      console.log('‚ÑπÔ∏è Trying IndexedDB fallback for JSON...');
      jsonData = await loadFileFromIndexedDB('json');
    }
    if (jsonData && jsonData.file) {
      document.getElementById('json-file-name').textContent = jsonData.name;

      const fileReader = new FileReader();
      fileReader.onload = function() {
        try {
          const data = JSON.parse(this.result);
          if (data && data.sentences && Array.isArray(data.sentences)) {
            manifest = data.sentences;
            fileTracker.json = true;
            console.log('‚úÖ JSON manifest restored from cache');
            checkAllFilesLoaded();
          } else {
            console.warn('‚ö†Ô∏è Cached JSON has invalid format');
          }
        } catch (err) {
          console.error('‚ùå Error parsing cached JSON:', err);
        }
      };
      fileReader.readAsText(jsonData.file);
    }

    // Check storage usage
    await checkStorageUsage();

  } catch (err) {
    console.error('‚ùå Error restoring files from IndexedDB:', err);
  }
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(registration => {
        console.log('‚úÖ Service Worker registered successfully:', registration.scope);

        // Check for updates periodically
        setInterval(() => {
          registration.update();
        }, 60000); // Check every minute

        // Handle service worker updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker available, show update notification
              if (confirm('New version available! Reload to update?')) {
                newWorker.postMessage({ type: 'SKIP_WAITING' });
                window.location.reload();
              }
            }
          });
        });
      })
      .catch(error => {
        console.log('‚ùå Service Worker registration failed:', error);
      });

    // Handle service worker controller change (new SW activated)
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      console.log('üîÑ Service Worker controller changed, reloading page...');
      window.location.reload();
    });
  });
}

// Add to home screen prompt (for supported browsers)
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  console.log('üíæ Install prompt available');
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;

  // Optionally, show your own install button
  // You could add a button in the UI here to trigger installation
});

window.addEventListener('appinstalled', () => {
  console.log('‚úÖ PWA installed successfully!');
  deferredPrompt = null;
});

// Alternative: Load MP3 as base64 data URL (more compatible offline)
async function loadMp3AsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Test play audio button handler
testPlayAudioButton.addEventListener('click', async () => {
  console.log('üß™ Testing audio playback...');
  console.log('   Current state:', {
    src: audioPlayer.src.substring(0, 50) + '...',
    srcLength: audioPlayer.src.length,
    readyState: audioPlayer.readyState,
    networkState: audioPlayer.networkState,
    paused: audioPlayer.paused,
    disabled: audioPlayer.disabled,
    duration: audioPlayer.duration,
    currentTime: audioPlayer.currentTime
  });

  if (audioPlayer.disabled) {
    console.warn('‚ö†Ô∏è Audio player is disabled, enabling it...');
    audioPlayer.disabled = false;
  }

  // Check if we have the file in memory
  if (currentMp3File) {
    console.log('üìÅ Current MP3 file in memory:', {
      name: currentMp3File.name,
      size: currentMp3File.size,
      type: currentMp3File.type
    });

    // Verify the file actually has data
    try {
      const testBuffer = await currentMp3File.slice(0, 100).arrayBuffer();
      console.log('‚úÖ File has readable data, first 100 bytes length:', testBuffer.byteLength);

      // Check for MP3 magic bytes (should start with FF FB or FF F3 or ID3)
      const firstBytes = new Uint8Array(testBuffer).slice(0, 3);
      const hexString = Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
      console.log('üîç First 3 bytes (hex):', hexString);

      if (firstBytes[0] === 0xFF || (firstBytes[0] === 0x49 && firstBytes[1] === 0x44 && firstBytes[2] === 0x33)) {
        console.log('‚úÖ MP3 magic bytes present - file appears valid');
      } else {
        console.warn('‚ö†Ô∏è Unexpected file header - may not be valid MP3');
      }
    } catch (err) {
      console.error('‚ùå Cannot read file data:', err);
    }
  } else {
    console.warn('‚ö†Ô∏è No MP3 file in currentMp3File variable!');
  }

  try {
    console.log('‚ñ∂Ô∏è Attempting to play...');
    const playPromise = audioPlayer.play();

    if (playPromise !== undefined) {
      playPromise
        .then(() => {
          console.log('‚úÖ Play promise succeeded!');

          // Check if it's actually playing after 2 seconds (give it more time)
          setTimeout(() => {
            console.log('üîç Checking playback after 2 seconds...');
            console.log('   CurrentTime:', audioPlayer.currentTime);
            console.log('   Paused:', audioPlayer.paused);
            console.log('   ReadyState:', audioPlayer.readyState);
            console.log('   Duration:', audioPlayer.duration);

            if (audioPlayer.currentTime === 0 && !audioPlayer.paused) {
              console.error('‚ùå Play succeeded but audio stuck at 0:00!');
              console.warn('‚ö†Ô∏è NOTE: If you can manually play it by clicking the play button, the audio file is fine!');
              console.warn('‚ö†Ô∏è This might be an iOS autoplay restriction or JavaScript play() API issue');
              testPlayAudioButton.textContent = '‚ùå Try Manual Play Button';

              // Try to reload with the file we have in memory
              if (currentMp3File) {
                console.log('üí° Try clicking the audio player play button directly');
                forceLoadAudioButton.style.display = 'block';
              }
            } else if (audioPlayer.currentTime > 0) {
              console.log('‚úÖ Audio is actually playing! CurrentTime:', audioPlayer.currentTime);
              testPlayAudioButton.textContent = '‚úÖ Playing!';
              setTimeout(() => {
                testPlayAudioButton.style.display = 'none';
              }, 2000);
            } else if (audioPlayer.paused) {
              console.warn('‚ö†Ô∏è Audio was paused automatically (might be autoplay policy)');
              testPlayAudioButton.textContent = '‚ö†Ô∏è Paused - Click Play Manually';
            }
          }, 2000);
        })
        .catch(error => {
          console.error('‚ùå Play promise failed:', {
            name: error.name,
            message: error.message,
            code: error.code
          });
          testPlayAudioButton.textContent = '‚ùå Play Failed: ' + error.name;
        });
    }
  } catch (err) {
    console.error('‚ùå Exception when trying to play:', err);
  }
});

// Force load audio button handler
forceLoadAudioButton.addEventListener('click', async () => {
  console.log('üîÑ Manually forcing audio load...');
  forceLoadAudioButton.textContent = '‚è≥ Loading...';
  forceLoadAudioButton.disabled = true;

  if (!currentMp3File) {
    console.error('‚ùå No MP3 file available to load');
    forceLoadAudioButton.textContent = '‚ùå No File Available';
    return;
  }

  try {
    console.log('üìÅ Reloading audio from file:', {
      name: currentMp3File.name,
      size: currentMp3File.size,
      type: currentMp3File.type
    });

    // Revoke old blob URL
    if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
      URL.revokeObjectURL(audioPlayer.src);
    }

    // Create fresh blob URL
    const url = URL.createObjectURL(currentMp3File);
    console.log('‚úÖ Fresh blob URL created:', url);

    audioPlayer.src = url;
    audioPlayer.load();
    console.log('üéµ Audio source set and load() called');

    // Wait for it to be ready to play
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Timeout after 10 seconds')), 10000);

      const onCanPlay = () => {
        clearTimeout(timeout);
        console.log('‚úÖ Audio canplay event fired');
        resolve();
      };

      const onError = () => {
        clearTimeout(timeout);
        console.error('‚ùå Audio error event fired:', audioPlayer.error);
        reject(audioPlayer.error || new Error('Unknown audio error'));
      };

      audioPlayer.addEventListener('canplay', onCanPlay, { once: true });
      audioPlayer.addEventListener('error', onError, { once: true });
    });

    console.log('‚úÖ Audio loaded successfully!');
    forceLoadAudioButton.style.display = 'none';
    forceLoadAudioButton.disabled = false;
    forceLoadAudioButton.textContent = 'üîÑ Force Load Audio';
    showStatus('Audio loaded! Try playing now.', false, false);
    setTimeout(() => statusBox.style.display = 'none', 3000);

  } catch (err) {
    console.error('‚ùå Manual load failed:', err);
    forceLoadAudioButton.textContent = '‚ùå Load Failed - Try Again';
    forceLoadAudioButton.disabled = false;
    showStatus('Failed to load audio: ' + (err.message || 'Unknown error'), false, true);
  }
});

// v18-simple: DISABLED cache restoration
// Restore files from Cache on page load
// window.addEventListener('load', () => {
//   restoreFilesFromCache();
// });
console.log('‚ö†Ô∏è v18-simple: Cache restoration DISABLED - no offline support');

// Reset data button handler
document.getElementById('reset-data-button').addEventListener('click', async () => {
  const confirmed = confirm('‚ö†Ô∏è This will delete all cached files (PDF, MP3, JSON). You will need to re-upload them to use the app offline.\n\nAre you sure you want to continue?');

  if (!confirmed) {
    return;
  }

  try {
    showStatus('Clearing all cached data...', true, false);

    // Clear Cache API user files
    await clearCachedFiles();

    // Clear IndexedDB (fallback)
    await clearAllIndexedDBData();

    // Clear service worker app cache
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      const appCaches = cacheNames.filter(name => name.startsWith('pdf-audio-player-v'));
      await Promise.all(appCaches.map(name => caches.delete(name)));
      console.log('‚úÖ Service Worker caches cleared');
    }

    // Reset UI
    document.getElementById('pdf-file-name').textContent = 'No file selected';
    document.getElementById('mp3-file-name').textContent = 'No file selected';
    document.getElementById('json-file-name').textContent = 'No file selected';

    // Reset application state
    pdfDoc = null;
    manifest = null;
    fileTracker = { pdf: false, mp3: false, json: false };
    currentAudioPage = null;
    currentUserPage = null;
    pageViewports = {};

    // Clear PDF viewer
    pdfContainer.innerHTML = '';
    viewerPlaceholder.style.display = 'block';

    // Clear audio player
    if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
      URL.revokeObjectURL(audioPlayer.src);
    }
    audioPlayer.src = '';
    audioPlayer.disabled = true;

    // Update displays
    updatePageDisplays();

    showStatus('‚úÖ All cached data cleared successfully!', false, false);
    setTimeout(() => {
      statusBox.style.display = 'none';
    }, 3000);

    console.log('‚úÖ All data reset complete');

  } catch (err) {
    console.error('‚ùå Error clearing data:', err);
    showStatus('Error clearing data: ' + err.message, false, true);
  }
});
</script>
</body>
</html>