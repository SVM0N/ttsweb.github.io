<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="PDF Audio Player">
<title>PDF Audio Player</title>
<!-- PWA Manifest -->
<link rel="manifest" href="manifest.json">
<!-- Theme color for address bar -->
<meta name="theme-color" content="#f5f5f7">
<!-- iOS specific meta tags -->
<meta name="apple-touch-fullscreen" content="yes">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">
<link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
<link rel="apple-touch-icon" sizes="167x167" href="icons/icon-192x192.png">
<!-- Standard favicon -->
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512x512.png">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js"></script>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
-webkit-tap-highlight-color: transparent;
-webkit-touch-callout: none;
}
:root {
--bg-gradient-start: #f5f5f7;
--bg-gradient-mid: #fafafa;
--bg-gradient-end: #f0f0f2;
--glass-bg: rgba(255, 255, 255, 0.7);
--glass-border: rgba(255, 255, 255, 0.3);
--card-bg: rgba(255, 255, 255, 0.8);
--card-border: rgba(255, 255, 255, 0.5);
--text-primary: rgba(0, 0, 0, 0.8);
--text-secondary: rgba(0, 0, 0, 0.6);
--text-tertiary: rgba(0, 0, 0, 0.4);
--input-bg-start: rgba(255, 255, 255, 0.9);
--input-bg-end: rgba(255, 255, 255, 0.7);
--viewer-bg: rgba(255, 255, 255, 0.5);
--shadow-color: rgba(0, 0, 0, 0.1);
--inset-shadow: rgba(255, 255, 255, 0.8);
--slider-track: rgba(174, 174, 178, 0.3);
--slider-thumb: #86868b;
--slider-thumb-shadow: rgba(134, 134, 139, 0.3);
}
body.dark-mode {
--bg-gradient-start: #1c1c1e;
--bg-gradient-mid: #2c2c2e;
--bg-gradient-end: #1c1c1e;
--glass-bg: rgba(44, 44, 46, 0.8);
--glass-border: rgba(84, 84, 88, 0.3);
--card-bg: rgba(58, 58, 60, 0.8);
--card-border: rgba(84, 84, 88, 0.5);
--text-primary: rgba(255, 255, 255, 0.9);
--text-secondary: rgba(255, 255, 255, 0.6);
--text-tertiary: rgba(255, 255, 255, 0.4);
--input-bg-start: rgba(58, 58, 60, 0.9);
--input-bg-end: rgba(44, 44, 46, 0.7);
--viewer-bg: rgba(28, 28, 30, 0.6);
--shadow-color: rgba(0, 0, 0, 0.3);
--inset-shadow: rgba(84, 84, 88, 0.3);
--slider-track: rgba(84, 84, 88, 0.5);
--slider-thumb: #98989d;
--slider-thumb-shadow: rgba(152, 152, 157, 0.3);
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
overflow: hidden;
background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}
.app-container {
display: flex;
flex-direction: column;
height: 100vh;
height: 100dvh;
gap: 0;
}
.sidebar {
background: var(--glass-bg);
backdrop-filter: blur(40px) saturate(180%);
-webkit-backdrop-filter: blur(40px) saturate(180%);
border-bottom: 1px solid var(--glass-border);
box-shadow: 0 8px 32px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
padding: 16px;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.sidebar.collapsed {
height: auto !important;
}
.sidebar.collapsed .collapsible-content {
display: none;
}
@media (min-width: 768px) {
.sidebar.collapsed {
width: auto;
padding: 20px;
}
}
.toggle-button {
display: block;
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 12px;
padding: 12px;
margin-bottom: 12px;
cursor: pointer;
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
box-shadow: 0 4px 16px var(--shadow-color);
transition: all 0.2s ease;
text-align: center;
}
.toggle-button:active {
transform: scale(0.98);
}
.dark-mode-toggle {
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 12px;
padding: 10px;
cursor: pointer;
font-size: 20px;
box-shadow: 0 4px 16px var(--shadow-color);
transition: all 0.2s ease;
display: inline-flex;
align-items: center;
justify-content: center;
width: 44px;
height: 44px;
border: none;
}
.dark-mode-toggle:active {
transform: scale(0.95);
}
.header-with-toggle {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
}
.main-viewer {
flex: 1;
overflow-y: auto;
background: var(--viewer-bg);
backdrop-filter: blur(60px) saturate(150%);
-webkit-backdrop-filter: blur(60px) saturate(150%);
padding: 20px;
-webkit-overflow-scrolling: touch;
box-shadow: inset 0 1px 0 var(--inset-shadow);
}
h1 {
font-size: 32px;
font-weight: 700;
color: var(--text-primary);
letter-spacing: -0.5px;
margin-bottom: 0;
}
.subtitle {
font-size: 15px;
color: var(--text-secondary);
font-weight: 400;
line-height: 1.4;
margin-bottom: 16px;
}
.input-card {
background: var(--card-bg);
backdrop-filter: blur(20px) saturate(180%);
-webkit-backdrop-filter: blur(20px) saturate(180%);
border-radius: 16px;
border: 1px solid var(--card-border);
padding: 14px;
margin-bottom: 12px;
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.input-card:active {
transform: scale(0.98);
box-shadow: 0 2px 8px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.input-label {
display: block;
font-weight: 600;
font-size: 13px;
color: var(--text-secondary);
margin-bottom: 8px;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.file-inputs-combined {
display: flex;
flex-direction: column;
gap: 12px;
}
.file-input-row {
display: flex;
align-items: center;
gap: 10px;
padding: 10px;
background: var(--input-bg-start);
border-radius: 10px;
border: 1px dashed var(--card-border);
transition: all 0.2s ease;
cursor: pointer;
}
.file-input-row:active {
background: var(--input-bg-end);
border-color: var(--text-tertiary);
}
.file-input-icon {
font-size: 20px;
flex-shrink: 0;
}
.file-input-wrapper {
flex: 1;
min-width: 0;
}
.file-input-label {
font-size: 11px;
font-weight: 600;
color: var(--text-tertiary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 2px;
}
.file-input-name {
font-size: 13px;
font-weight: 500;
color: var(--text-primary);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
input[type="file"] {
display: none;
}
audio {
width: 100%;
height: 54px;
border-radius: 14px;
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.info-card {
background: linear-gradient(135deg, var(--card-bg) 0%, var(--card-bg) 100%);
backdrop-filter: blur(30px) saturate(180%);
-webkit-backdrop-filter: blur(30px) saturate(180%);
border-radius: 16px;
border: 1px solid var(--card-border);
padding: 16px;
margin: 12px 0;
box-shadow: 0 8px 24px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.zoom-controls {
display: flex;
align-items: center;
justify-content: space-between;
gap: 12px;
}
.zoom-label {
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
flex-shrink: 0;
}
.zoom-buttons {
display: flex;
gap: 8px;
}
.zoom-button {
background: var(--card-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 1px solid var(--card-border);
border-radius: 10px;
width: 44px;
height: 44px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
font-size: 20px;
font-weight: 600;
color: var(--text-primary);
box-shadow: 0 2px 8px var(--shadow-color);
transition: all 0.2s ease;
-webkit-user-select: none;
user-select: none;
}
.zoom-button:active {
transform: scale(0.95);
box-shadow: 0 1px 4px var(--shadow-color);
}
.zoom-value {
background: var(--card-bg);
padding: 8px 16px;
border-radius: 10px;
font-weight: 700;
font-size: 15px;
color: var(--text-primary);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
min-width: 60px;
text-align: center;
}
.status-box {
padding: 14px 16px;
border-radius: 14px;
margin: 16px 0;
font-size: 14px;
display: flex;
align-items: center;
gap: 10px;
font-weight: 500;
backdrop-filter: blur(20px) saturate(180%);
-webkit-backdrop-filter: blur(20px) saturate(180%);
border: 1px solid var(--card-border);
box-shadow: 0 4px 16px var(--shadow-color), inset 0 1px 0 var(--inset-shadow);
}
.status-loading {
background: var(--card-bg);
color: var(--text-primary);
}
.status-success {
background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.1) 100%);
color: rgba(30, 132, 73, 1);
}
.status-error {
background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.1) 100%);
color: rgba(215, 0, 21, 1);
}
input[type="range"] {
-webkit-appearance: none;
width: 100%;
height: 6px;
border-radius: 6px;
background: var(--slider-track);
outline: none;
margin: 12px 0;
box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}
input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 24px;
height: 24px;
border-radius: 50%;
background: var(--slider-thumb);
cursor: pointer;
box-shadow: 0 2px 6px var(--slider-thumb-shadow), 0 0 0 3px var(--card-bg);
transition: all 0.2s ease;
}
input[type="range"]::-webkit-slider-thumb:active {
transform: scale(1.1);
box-shadow: 0 3px 10px var(--slider-thumb-shadow), 0 0 0 4px var(--card-bg);
}
input[type="range"]::-moz-range-thumb {
width: 24px;
height: 24px;
border-radius: 50%;
background: var(--slider-thumb);
cursor: pointer;
border: none;
box-shadow: 0 2px 6px var(--slider-thumb-shadow), 0 0 0 3px var(--card-bg);
}
.page-container {
position: relative;
margin: 16px auto;
border-radius: 16px;
overflow: hidden;
box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.5);
touch-action: pan-y;
background: white;
backdrop-filter: blur(40px);
-webkit-backdrop-filter: blur(40px);
transition: transform 0.2s ease;
}
.highlight-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
}
.highlight-overlay.hidden {
display: none;
}
canvas {
display: block;
width: 100%;
height: 100%;
}
.highlight-box {
position: absolute;
background: rgba(255, 214, 10, 0.35);
border-radius: 2px;
transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
box-sizing: border-box;
left: 0;
width: 100%;
padding-top: 6px;
padding-bottom: 6px;
}
.page-badge {
display: inline-flex;
align-items: center;
gap: 8px;
font-size: 14px;
color: var(--text-primary);
margin-bottom: 8px;
font-weight: 500;
}
.page-number {
background: var(--card-bg);
padding: 4px 12px;
border-radius: 8px;
font-weight: 700;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
}
.placeholder {
text-align: center;
padding: 80px 20px;
color: var(--text-tertiary);
}
.placeholder svg {
width: 80px;
height: 80px;
margin: 0 auto 24px;
opacity: 0.3;
filter: drop-shadow(0 4px 8px var(--shadow-color));
}
.placeholder-title {
font-size: 22px;
font-weight: 700;
margin-bottom: 8px;
color: var(--text-secondary);
}
.placeholder-subtitle {
font-size: 15px;
font-weight: 400;
color: var(--text-tertiary);
}
@keyframes liquid-spin {
0% { transform: rotate(0deg) scale(1); }
50% { transform: rotate(180deg) scale(1.05); }
100% { transform: rotate(360deg) scale(1); }
}
.spinner {
width: 20px;
height: 20px;
border: 3px solid rgba(255, 255, 255, 0.3);
border-top-color: currentColor;
border-radius: 50%;
animation: liquid-spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
.speed-label {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 8px;
color: var(--text-primary);
}
.speed-value {
background: var(--card-bg);
padding: 4px 14px;
border-radius: 10px;
font-weight: 700;
font-size: 15px;
color: var(--text-primary);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: inset 0 1px 0 var(--inset-shadow);
border: 1px solid var(--card-border);
}
body.dark-mode .speed-value {
color: var(--text-primary);
}
.toggle-switch {
position: relative;
display: inline-block;
width: 51px;
height: 31px;
flex-shrink: 0;
}
.toggle-switch input {
opacity: 0;
width: 0;
height: 0;
}
.toggle-slider {
position: absolute;
cursor: pointer;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: var(--slider-track);
transition: 0.3s;
border-radius: 31px;
box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}
.toggle-slider:before {
position: absolute;
content: "";
height: 23px;
width: 23px;
left: 4px;
bottom: 4px;
background: white;
transition: 0.3s;
border-radius: 50%;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}
input:checked + .toggle-slider {
background: #34c759;
}
input:checked + .toggle-slider:before {
transform: translateX(20px);
}
.toggle-row {
display: flex;
justify-content: space-between;
align-items: center;
gap: 12px;
}
.toggle-label-text {
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
flex-grow: 1;
}
@media (min-width: 768px) {
.app-container {
flex-direction: row;
}
.sidebar {
width: 420px;
flex-shrink: 0;
height: 100vh;
height: 100dvh;
border-bottom: none;
border-right: 1px solid var(--glass-border);
box-shadow: 8px 0 32px var(--shadow-color), inset -1px 0 0 var(--inset-shadow);
}
.main-viewer {
padding: 40px;
}
h1 {
font-size: 38px;
}
}
@media (min-width: 768px) and (orientation: landscape) {
.sidebar {
width: 440px;
}
}
.overflow-y-auto {
-webkit-overflow-scrolling: touch;
overscroll-behavior: contain;
scroll-behavior: smooth;
}
label, h1, .subtitle, .status-box, .page-badge {
-webkit-user-select: none;
user-select: none;
}
.main-viewer {
-webkit-user-select: text;
user-select: text;
}
</style>
</head>
<body>
<div class="app-container">
<aside class="sidebar" id="sidebar">
<div class="toggle-button" id="toggle-button">
<span id="toggle-text">‚åÉ Show Controls</span>
</div>
<div style="margin-bottom: 12px;" id="collapsed-audio">
<audio id="audio-player" controls disabled preload="auto"></audio>
<button class="toggle-button" id="force-load-audio" style="display: none; margin-top: 8px; padding: 8px; font-size: 13px; background: linear-gradient(135deg, rgba(52, 199, 89, 0.15) 0%, rgba(52, 199, 89, 0.1) 100%); color: rgba(30, 132, 73, 1);">
üîÑ Force Load Audio
</button>
</div>
<div class="collapsible-content">
<div class="header-with-toggle">
<h1>PDF Audio Player</h1>
<div style="display: flex; gap: 8px;">
<button class="dark-mode-toggle" id="debug-mode-toggle" title="Toggle Debug Console">
<span id="debug-icon">üêõ</span>
</button>
<button class="dark-mode-toggle" id="dark-mode-toggle" title="Toggle Dark Mode">
<span id="theme-icon">üåô</span>
</button>
</div>
</div>
<p class="subtitle">Upload files for synchronized playback with highlighting</p>
<div class="input-card">
<label class="input-label">Upload Files</label>
<div class="file-inputs-combined">
<label class="file-input-row" for="pdf-file">
<span class="file-input-icon">üìÑ</span>
<div class="file-input-wrapper">
<div class="file-input-label">PDF Document</div>
<div class="file-input-name" id="pdf-file-name">No file selected</div>
</div>
</label>
<input type="file" id="pdf-file" accept=".pdf,application/pdf">
<label class="file-input-row" for="mp3-file">
<span class="file-input-icon">üéµ</span>
<div class="file-input-wrapper">
<div class="file-input-label">Audio File</div>
<div class="file-input-name" id="mp3-file-name">No file selected</div>
</div>
</label>
<input type="file" id="mp3-file" accept=".mp3,audio/mpeg,audio/*">
<label class="file-input-row" for="json-file">
<span class="file-input-icon">üìã</span>
<div class="file-input-wrapper">
<div class="file-input-label">JSON Manifest</div>
<div class="file-input-name" id="json-file-name">No file selected</div>
</div>
</label>
<input type="file" id="json-file" accept=".json,application/json">
</div>
</div>
<div id="status-box" class="status-box status-loading" style="display: none;">
<div id="loading-spinner" class="spinner"></div>
<span id="status-message">Loading...</span>
</div>
<div class="info-card">
<div class="speed-label">
<span style="font-weight: 600; font-size: 15px;">Playback Speed</span>
<span id="speed-value" class="speed-value">1.0x</span>
</div>
<input type="range" id="speed-slider" min="0.5" max="2.0" step="0.1" value="1.0">
<div class="toggle-row" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<span class="toggle-label-text">Show Highlighter</span>
<label class="toggle-switch">
<input type="checkbox" id="highlighter-toggle" checked>
<span class="toggle-slider"></span>
</label>
</div>
<div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<div class="speed-label">
<span style="font-weight: 600; font-size: 15px;">Highlight Offset</span>
<span id="offset-value" class="speed-value">0%</span>
</div>
<input type="range" id="offset-slider" min="-15" max="15" step="1" value="0">
</div>
<div class="zoom-controls" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--card-border);">
<span class="zoom-label">PDF Zoom</span>
<div style="display: flex; align-items: center; gap: 8px;">
<span id="zoom-value" class="zoom-value">100%</span>
<div class="zoom-buttons">
<button class="zoom-button" id="zoom-out" title="Zoom Out">‚àí</button>
<button class="zoom-button" id="zoom-in" title="Zoom In">+</button>
</div>
</div>
</div>
</div>
<div class="info-card">
<div class="page-badge" id="audio-page-display">
üìñ Reading: <span class="page-number">-</span>
</div>
<div class="page-badge" id="user-page-display">
üëÅÔ∏è Viewing: <span class="page-number">-</span>
</div>
</div>
<div class="input-card">
<button class="toggle-button" id="reset-data-button" style="background: linear-gradient(135deg, rgba(255, 59, 48, 0.15) 0%, rgba(255, 59, 48, 0.1) 100%); color: rgba(215, 0, 21, 1); margin-bottom: 0;">
üóëÔ∏è Clear All Cached Data
</button>
</div>
<div class="input-card" id="debug-console-card" style="display: none;">
<label class="input-label">Debug Console</label>
<div id="debug-console" style="font-family: monospace; font-size: 11px; max-height: 200px; overflow-y: auto; background: var(--input-bg-start); padding: 10px; border-radius: 8px; color: var(--text-primary);"></div>
<button class="toggle-button" id="clear-console-button" style="margin-top: 8px; padding: 8px; font-size: 12px;">Clear Console</button>
</div>
</div>
</aside>
<main class="main-viewer" id="pdf-viewer">
<div id="pdf-container">
<div id="viewer-placeholder" class="placeholder">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
</svg>
<div class="placeholder-title">No Document Loaded</div>
<div class="placeholder-subtitle">Upload a PDF file to begin</div>
</div>
</div>
</main>
</div>
<script>
let pdfDoc = null;
let manifest = null;
let pageViewports = {};
let audioPlayer = document.getElementById('audio-player');
let pdfContainer = document.getElementById('pdf-container');
let viewerPlaceholder = document.getElementById('viewer-placeholder');
let statusBox = document.getElementById('status-box');
let statusMessage = document.getElementById('status-message');
let loadingSpinner = document.getElementById('loading-spinner');
let audioPageDisplay = document.getElementById('audio-page-display');
let userPageDisplay = document.getElementById('user-page-display');
let speedSlider = document.getElementById('speed-slider');
let speedValueDisplay = document.getElementById('speed-value');
let highlighterToggle = document.getElementById('highlighter-toggle');
let offsetSlider = document.getElementById('offset-slider');
let offsetValueDisplay = document.getElementById('offset-value');
let currentHighlight = null;
let currentHighlightSentence = null;
let currentAudioPage = null;
let currentUserPage = null;
let pdfScale = 1.5;
let fileTracker = { pdf: false, mp3: false, json: false };
let intersectionObserver = null;
let zoomLevel = 100;
let highlighterEnabled = true;
let highlightOffset = 0;
const zoomStep = 25;
const minZoom = 50;
const maxZoom = 200;
const zoomInButton = document.getElementById('zoom-in');
const zoomOutButton = document.getElementById('zoom-out');
const zoomValueDisplay = document.getElementById('zoom-value');
const forceLoadAudioButton = document.getElementById('force-load-audio');
let currentMp3File = null; // Store the current MP3 file for manual reloading
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
const darkModeToggle = document.getElementById('dark-mode-toggle');
const themeIcon = document.getElementById('theme-icon');
const currentTheme = localStorage.getItem('theme');
if (currentTheme === 'dark') {
document.body.classList.add('dark-mode');
themeIcon.textContent = '‚òÄÔ∏è';
}
darkModeToggle.addEventListener('click', () => {
document.body.classList.toggle('dark-mode');
const isDark = document.body.classList.contains('dark-mode');
themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
localStorage.setItem('theme', isDark ? 'dark' : 'light');
});
highlighterToggle.addEventListener('change', (e) => {
highlighterEnabled = e.target.checked;
const overlays = document.querySelectorAll('.highlight-overlay');
overlays.forEach(overlay => {
if (highlighterEnabled) {
overlay.classList.remove('hidden');
} else {
overlay.classList.add('hidden');
}
});
localStorage.setItem('highlighterEnabled', highlighterEnabled ? 'true' : 'false');
});
const savedHighlighterState = localStorage.getItem('highlighterEnabled');
if (savedHighlighterState === 'false') {
highlighterEnabled = false;
highlighterToggle.checked = false;
}
offsetSlider.addEventListener('input', (e) => {
highlightOffset = parseInt(e.target.value, 10);
offsetValueDisplay.textContent = `${highlightOffset > 0 ? '+' : ''}${highlightOffset}%`;
localStorage.setItem('highlightOffset', highlightOffset);
if (manifest && currentHighlightSentence !== null && highlighterEnabled) {
const currentSentence = manifest.find(s => s.i === currentHighlightSentence);
if (currentSentence) {
drawHighlight(currentSentence);
}
}
});
const savedOffset = localStorage.getItem('highlightOffset');
if (savedOffset !== null) {
highlightOffset = parseInt(savedOffset, 10);
offsetSlider.value = highlightOffset;
offsetValueDisplay.textContent = `${highlightOffset > 0 ? '+' : ''}${highlightOffset}%`;
}
zoomInButton.addEventListener('click', () => {
if (zoomLevel < maxZoom) {
zoomLevel += zoomStep;
updateZoom();
}
});
zoomOutButton.addEventListener('click', () => {
if (zoomLevel > minZoom) {
zoomLevel -= zoomStep;
updateZoom();
}
});
function updateZoom() {
zoomValueDisplay.textContent = `${zoomLevel}%`;
const containers = document.querySelectorAll('.page-container');
const zoomScale = zoomLevel / 100;
containers.forEach((container, index) => {
container.style.transform = `scale(${zoomScale})`;
container.style.transformOrigin = 'top center';
if (index < containers.length - 1) {
const originalHeight = container.offsetHeight;
const scaledHeight = originalHeight * zoomScale;
const marginAdjustment = originalHeight - scaledHeight;
container.style.marginBottom = `${16 - marginAdjustment}px`;
}
});
}
document.getElementById('pdf-file').addEventListener('change', handlePdfUpload);
document.getElementById('mp3-file').addEventListener('change', handleMp3Upload);
document.getElementById('json-file').addEventListener('change', handleJsonUpload);
audioPlayer.addEventListener('timeupdate', handleTimeUpdate);
speedSlider.addEventListener('input', handleSpeedChange);
const toggleButton = document.getElementById('toggle-button');
const toggleText = document.getElementById('toggle-text');
const sidebar = document.getElementById('sidebar');
let isCollapsed = false;
if (toggleButton) {
toggleButton.addEventListener('click', () => {
isCollapsed = !isCollapsed;
if (isCollapsed) {
sidebar.classList.add('collapsed');
toggleText.textContent = '‚åÑ Hide Controls';
} else {
sidebar.classList.remove('collapsed');
toggleText.textContent = '‚åÉ Show Controls';
}
});
}
async function handlePdfUpload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('pdf-file-name').textContent = file.name;
viewerPlaceholder.style.display = 'none';
showStatus('Rendering PDF pages...', true);
pageViewports = {};
currentUserPage = null;
currentAudioPage = null;
if (intersectionObserver) intersectionObserver.disconnect();

// Save to IndexedDB for offline access
try {
await saveFileToIndexedDB('pdf', file);
} catch (err) {
console.error('Failed to save PDF to IndexedDB:', err);
}

const fileReader = new FileReader();
fileReader.onload = function() {
const typedarray = new Uint8Array(this.result);
const loadingTask = pdfjsLib.getDocument(typedarray);
loadingTask.promise.then(pdf => {
pdfDoc = pdf;
fileTracker.pdf = true;
pdfContainer.innerHTML = '';
renderAllPages();
}).catch(err => {
showStatus('Error loading PDF: ' + err.message, false, true);
console.error('PDF Load Error:', err);
});
};
fileReader.readAsArrayBuffer(file);
}
async function handleMp3Upload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('mp3-file-name').textContent = file.name;

console.log('üìÅ MP3 File Details:', {
  name: file.name,
  size: file.size,
  type: file.type,
  lastModified: file.lastModified
});

// Save to IndexedDB for offline access
try {
await saveFileToIndexedDB('mp3', file);
console.log('‚úÖ MP3 saved to IndexedDB successfully');
} catch (err) {
console.error('‚ùå Failed to save MP3 to IndexedDB:', err);
}

if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
URL.revokeObjectURL(audioPlayer.src);
}
const url = URL.createObjectURL(file);
console.log('üîó Created blob URL for audio:', url);

audioPlayer.src = url;
audioPlayer.load(); // Force the audio to load
console.log('üéµ Audio player src set to:', audioPlayer.src);
console.log('üéµ Audio player ready state:', audioPlayer.readyState);
console.log('üéµ Audio player network state:', audioPlayer.networkState);

fileTracker.mp3 = true;
checkAllFilesLoaded();

// Add event listeners to debug audio loading (only once)
if (!audioPlayer.hasAttribute('data-listeners-added')) {
  audioPlayer.setAttribute('data-listeners-added', 'true');

  audioPlayer.addEventListener('loadstart', () => console.log('üéµ Audio: loadstart'));
  audioPlayer.addEventListener('loadedmetadata', () => console.log('‚úÖ Audio: loadedmetadata'));
  audioPlayer.addEventListener('loadeddata', () => console.log('‚úÖ Audio: loadeddata'));
  audioPlayer.addEventListener('canplay', () => console.log('‚úÖ Audio: canplay'));
  audioPlayer.addEventListener('canplaythrough', () => console.log('‚úÖ Audio: canplaythrough'));
  audioPlayer.addEventListener('error', (e) => {
    console.error('‚ùå Audio Error:', {
      error: audioPlayer.error,
      code: audioPlayer.error?.code,
      message: audioPlayer.error?.message,
      event: e
    });
  });
  audioPlayer.addEventListener('stalled', () => console.warn('‚ö†Ô∏è Audio: stalled'));
  audioPlayer.addEventListener('suspend', () => console.warn('‚ö†Ô∏è Audio: suspend'));
  audioPlayer.addEventListener('abort', () => console.warn('‚ö†Ô∏è Audio: abort'));
}

// Store file for manual reload
currentMp3File = file;

// Fallback: If audio doesn't start loading within 3 seconds, try data URL
setTimeout(async () => {
  if (audioPlayer.readyState === 0 || audioPlayer.networkState === 3) {
    console.warn('‚ö†Ô∏è Audio not loading with blob URL, trying data URL fallback...');
    try {
      const dataURL = await loadMp3AsDataURL(file);
      audioPlayer.src = dataURL;
      audioPlayer.load();
      console.log('‚úÖ Switched to data URL for audio');

      // If still not loading after 2 more seconds, show manual button
      setTimeout(() => {
        if (audioPlayer.readyState === 0) {
          console.warn('‚ö†Ô∏è Audio still not loading, showing manual load button');
          forceLoadAudioButton.style.display = 'block';
        }
      }, 2000);
    } catch (err) {
      console.error('‚ùå Data URL fallback failed:', err);
      forceLoadAudioButton.style.display = 'block';
    }
  }
}, 3000);
}
async function handleJsonUpload(e) {
const file = e.target.files[0];
if (!file) return;
document.getElementById('json-file-name').textContent = file.name;

// Save to IndexedDB for offline access
try {
await saveFileToIndexedDB('json', file);
} catch (err) {
console.error('Failed to save JSON to IndexedDB:', err);
}

const fileReader = new FileReader();
fileReader.onload = function() {
try {
const data = JSON.parse(this.result);
if (data && data.sentences && Array.isArray(data.sentences)) {
manifest = data.sentences;
fileTracker.json = true;
checkAllFilesLoaded();
} else {
showStatus('Invalid JSON: Missing "sentences" array', false, true);
}
} catch (err) {
showStatus('Error parsing JSON file', false, true);
console.error('JSON Parse Error:', err);
}
};
fileReader.readAsText(file);
}
function handleSpeedChange(e) {
const speed = parseFloat(e.target.value);
if (audioPlayer && !isNaN(speed)) {
audioPlayer.playbackRate = speed;
speedValueDisplay.textContent = `${speed.toFixed(1)}x`;
}
}
function checkAllFilesLoaded() {
if (fileTracker.pdf && fileTracker.mp3 && fileTracker.json) {
showStatus('Ready to play!', false, false);
audioPlayer.disabled = false;
const initialSpeed = parseFloat(speedSlider.value) || 1.0;
audioPlayer.playbackRate = initialSpeed;
speedValueDisplay.textContent = `${initialSpeed.toFixed(1)}x`;
updatePageDisplays();
setTimeout(() => {
statusBox.style.display = 'none';
}, 2000);
} else {
let missing = [];
if (!fileTracker.pdf) missing.push('PDF');
if (!fileTracker.mp3) missing.push('MP3');
if (!fileTracker.json) missing.push('JSON');
showStatus('Waiting for: ' + missing.join(', '), true, false);
currentAudioPage = null;
currentUserPage = null;
updatePageDisplays();
}
}
async function renderAllPages() {
if (!pdfDoc) return;
const numPages = pdfDoc.numPages;
showStatus(`Rendering ${numPages} page${numPages > 1 ? 's' : ''}...`, true, false);
for (let i = 1; i <= numPages; i++) {
const page = await pdfDoc.getPage(i);
pageViewports[i] = page.getViewport({ scale: 1.0 });
const viewport = page.getViewport({ scale: pdfScale });
const pageContainer = document.createElement('div');
pageContainer.id = `page-container-${i}`;
pageContainer.className = 'page-container';
pageContainer.style.width = `${viewport.width}px`;
pageContainer.style.height = `${viewport.height}px`;
pageContainer.dataset.pageNumber = i;
const canvas = document.createElement('canvas');
canvas.id = `pdf-canvas-${i}`;
canvas.width = viewport.width;
canvas.height = viewport.height;
const highlightOverlay = document.createElement('div');
highlightOverlay.id = `highlight-overlay-${i}`;
highlightOverlay.className = 'highlight-overlay';
if (!highlighterEnabled) {
highlightOverlay.classList.add('hidden');
}
pageContainer.appendChild(canvas);
pageContainer.appendChild(highlightOverlay);
pdfContainer.appendChild(pageContainer);
const renderContext = {
canvasContext: canvas.getContext('2d'),
viewport: viewport
};
try {
await page.render(renderContext).promise;
} catch (err) {
console.error(`Error rendering page ${i}:`, err);
}
}
setupIntersectionObserver();
checkAllFilesLoaded();
}
function setupIntersectionObserver() {
const options = {
root: document.getElementById('pdf-viewer'),
rootMargin: '0px',
threshold: 0.5
};
intersectionObserver = new IntersectionObserver(handleIntersection, options);
document.querySelectorAll('.page-container').forEach(pageEl => {
intersectionObserver.observe(pageEl);
});
}
function handleIntersection(entries) {
entries.forEach(entry => {
if (entry.isIntersecting) {
const newPage = parseInt(entry.target.dataset.pageNumber, 10);
if (newPage !== currentUserPage) {
currentUserPage = newPage;
updatePageDisplays();
}
}
});
}
function handleTimeUpdate() {
if (!manifest || audioPlayer.paused) return;
const currentTime = audioPlayer.currentTime;
const sentence = findSentenceForTime(currentTime);
if (sentence) {
const newPage = sentence.location?.page_number;
if (newPage && newPage !== currentAudioPage) {
currentAudioPage = newPage;
updatePageDisplays();
}
if (sentence.i !== currentHighlightSentence) {
currentHighlightSentence = sentence.i;
if (highlighterEnabled) {
drawHighlight(sentence);
}
}
}
}
function findSentenceForTime(time) {
return manifest.find(s => time >= s.start && time < s.end);
}
function drawHighlight(sentence) {
if (currentHighlight) {
currentHighlight.remove();
currentHighlight = null;
}
const loc = sentence.location;
if (!loc || !loc.page_number || !loc.points) return;
const coords = loc.points;
if (!Array.isArray(coords) || coords.length < 3 ||
!Array.isArray(coords[0]) || coords[0].length < 2 ||
!Array.isArray(coords[2]) || coords[2].length < 2) return;
const y_min_raw = coords[0][1];
const y_max_raw = coords[2][1];
if (typeof y_min_raw !== 'number' || typeof y_max_raw !== 'number' || y_max_raw <= y_min_raw) return;
const pageNum = loc.page_number;
const overlay = document.getElementById(`highlight-overlay-${pageNum}`);
const canvas = document.getElementById(`pdf-canvas-${pageNum}`);
const pageViewport = pageViewports[pageNum];
if (!overlay || !canvas || !pageViewport) return;
// Use actual PDF page height (at scale 1.0) for correct normalization
// Coordinates from PyMuPDF/unstructured are in PDF points (scale 1.0)
const pdfPageHeight = pageViewport.height;
const canvasHeight = canvas.height;
// Normalize using actual page height, then scale to canvas
const norm_y_min = y_min_raw / pdfPageHeight;
const norm_y_max = y_max_raw / pdfPageHeight;
const clamped_norm_y_min = Math.max(0, Math.min(1, norm_y_min));
const clamped_norm_y_max = Math.max(0, Math.min(1, norm_y_max));
let final_y = clamped_norm_y_min * canvasHeight;
const final_height = (clamped_norm_y_max - clamped_norm_y_min) * canvasHeight;
const offsetPixels = (highlightOffset / 100) * canvasHeight;
final_y += offsetPixels;
final_y = Math.max(0, Math.min(canvasHeight - final_height, final_y));
const box = document.createElement('div');
box.className = 'highlight-box';
box.style.top = `${final_y}px`;
box.style.height = `${final_height}px`;
overlay.appendChild(box);
currentHighlight = box;
}
function showStatus(message, isLoading, isError) {
statusBox.style.display = 'flex';
statusMessage.textContent = message;
loadingSpinner.style.display = isLoading ? 'inline-block' : 'none';
if (isError) {
statusBox.className = 'status-box status-error';
} else if (isLoading) {
statusBox.className = 'status-box status-loading';
} else {
statusBox.className = 'status-box status-success';
}
}
function updatePageDisplays() {
const totalPages = pdfDoc ? pdfDoc.numPages : '-';
const reading = currentAudioPage ?? '-';
const viewing = currentUserPage ?? '-';
audioPageDisplay.innerHTML = `üìñ Reading: <span class="page-number">${reading} / ${totalPages}</span>`;
userPageDisplay.innerHTML = `üëÅÔ∏è Viewing: <span class="page-number">${viewing} / ${totalPages}</span>`;
}
let lastTouchEnd = 0;
document.addEventListener('touchend', (event) => {
const now = Date.now();
if (now - lastTouchEnd <= 300) {
event.preventDefault();
}
lastTouchEnd = now;
}, false);
document.addEventListener('gesturestart', (e) => e.preventDefault());
document.addEventListener('gesturechange', (e) => e.preventDefault());
document.addEventListener('gestureend', (e) => e.preventDefault());
let orientationChangeTimeout;
window.addEventListener('orientationchange', () => {
clearTimeout(orientationChangeTimeout);
orientationChangeTimeout = setTimeout(() => {
console.log('Orientation changed');
}, 100);
});
console.log('‚úÖ PDF Audio Player loaded with highlighter toggle!');

// ========================================
// On-Screen Debug Console for Mobile
// ========================================

const debugConsoleElement = document.getElementById('debug-console');
const debugConsoleCard = document.getElementById('debug-console-card');
let debugMode = localStorage.getItem('debugMode') === 'true';

// Show debug console if enabled
if (debugMode) {
  debugConsoleCard.style.display = 'block';
}

// Function to add log to on-screen console
function debugLog(message, type = 'log') {
  if (!debugMode) return;

  const timestamp = new Date().toLocaleTimeString();
  const colors = {
    log: 'var(--text-primary)',
    error: '#ff3b30',
    warn: '#ff9500',
    success: '#34c759'
  };

  const logEntry = document.createElement('div');
  logEntry.style.color = colors[type] || colors.log;
  logEntry.style.marginBottom = '4px';
  logEntry.style.borderBottom = '1px solid var(--card-border)';
  logEntry.style.paddingBottom = '4px';
  logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;

  debugConsoleElement.appendChild(logEntry);
  debugConsoleElement.scrollTop = debugConsoleElement.scrollHeight;
}

// Override console methods to show in on-screen console
const originalLog = console.log;
const originalError = console.error;
const originalWarn = console.warn;

console.log = function(...args) {
  originalLog.apply(console, args);
  debugLog(args.join(' '), 'log');
};

console.error = function(...args) {
  originalError.apply(console, args);
  debugLog('ERROR: ' + args.join(' '), 'error');
};

console.warn = function(...args) {
  originalWarn.apply(console, args);
  debugLog('WARN: ' + args.join(' '), 'warn');
};

// Toggle debug mode with button
const debugModeToggle = document.getElementById('debug-mode-toggle');
const debugIcon = document.getElementById('debug-icon');

debugModeToggle.addEventListener('click', () => {
  debugMode = !debugMode;
  localStorage.setItem('debugMode', debugMode);
  debugConsoleCard.style.display = debugMode ? 'block' : 'none';

  if (debugMode) {
    debugIcon.textContent = 'üü¢';
    debugLog('üêõ Debug mode enabled', 'success');
    showStatus('Debug mode enabled! Console visible.', false, false);
  } else {
    debugIcon.textContent = 'üêõ';
    showStatus('Debug mode disabled.', false, false);
  }

  setTimeout(() => {
    statusBox.style.display = 'none';
  }, 2000);
});

// Clear console button
document.getElementById('clear-console-button').addEventListener('click', () => {
  debugConsoleElement.innerHTML = '';
  debugLog('Console cleared', 'log');
});

// ========================================
// IndexedDB Storage for Offline Support
// ========================================

const DB_NAME = 'pdfAudioPlayerDB';
const DB_VERSION = 1;
const STORE_NAME = 'userFiles';

// Open or create IndexedDB
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      console.error('‚ùå IndexedDB failed to open:', request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      console.log('‚úÖ IndexedDB opened successfully');
      resolve(request.result);
    };

    request.onupgradeneeded = (event) => {
      console.log('üîß IndexedDB upgrade needed, creating object store...');
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'type' });
        console.log('‚úÖ Object store created');
      }
    };
  });
}

// Save file to IndexedDB
async function saveFileToIndexedDB(type, file) {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    await store.put({
      type: type,
      file: file,
      name: file.name,
      size: file.size,
      lastModified: file.lastModified
    });

    console.log(`‚úÖ Saved ${type} file to IndexedDB:`, file.name);
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  } catch (err) {
    console.error(`‚ùå Error saving ${type} to IndexedDB:`, err);
    throw err;
  }
}

// Load file from IndexedDB
async function loadFileFromIndexedDB(type) {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);

    return new Promise((resolve, reject) => {
      const request = store.get(type);
      request.onsuccess = () => {
        if (request.result) {
          console.log(`‚úÖ Loaded ${type} from IndexedDB:`, request.result.name);
          resolve(request.result);
        } else {
          resolve(null);
        }
      };
      request.onerror = () => reject(request.error);
    });
  } catch (err) {
    console.error(`‚ùå Error loading ${type} from IndexedDB:`, err);
    return null;
  }
}

// Clear all data from IndexedDB
async function clearAllIndexedDBData() {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    await store.clear();
    console.log('‚úÖ All IndexedDB data cleared');

    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  } catch (err) {
    console.error('‚ùå Error clearing IndexedDB:', err);
    throw err;
  }
}

// Check storage usage
async function checkStorageUsage() {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    const usedMB = (estimate.usage / 1024 / 1024).toFixed(2);
    const quotaMB = (estimate.quota / 1024 / 1024).toFixed(2);
    console.log(`üíæ Storage: ${usedMB} MB used of ${quotaMB} MB available`);
    return { used: usedMB, quota: quotaMB };
  }
  return null;
}

// Restore files from IndexedDB on app startup
async function restoreFilesFromIndexedDB() {
  console.log('üîÑ Checking for cached files in IndexedDB...');

  try {
    // Restore PDF
    const pdfData = await loadFileFromIndexedDB('pdf');
    if (pdfData && pdfData.file) {
      document.getElementById('pdf-file-name').textContent = pdfData.name;
      viewerPlaceholder.style.display = 'none';
      showStatus('Restoring PDF from cache...', true);

      const fileReader = new FileReader();
      fileReader.onload = function() {
        const typedarray = new Uint8Array(this.result);
        const loadingTask = pdfjsLib.getDocument(typedarray);
        loadingTask.promise.then(pdf => {
          pdfDoc = pdf;
          fileTracker.pdf = true;
          pdfContainer.innerHTML = '';
          renderAllPages();
          console.log('‚úÖ PDF restored from cache');
        }).catch(err => {
          showStatus('Error loading cached PDF: ' + err.message, false, true);
          console.error('PDF Load Error:', err);
        });
      };
      fileReader.readAsArrayBuffer(pdfData.file);
    }

    // Restore MP3
    const mp3Data = await loadFileFromIndexedDB('mp3');
    if (mp3Data && mp3Data.file) {
      document.getElementById('mp3-file-name').textContent = mp3Data.name;

      console.log('üìÅ Restoring MP3 from cache:', {
        name: mp3Data.name,
        size: mp3Data.size,
        type: mp3Data.file.type,
        isFile: mp3Data.file instanceof File,
        isBlob: mp3Data.file instanceof Blob
      });

      // Store file for manual reload
      currentMp3File = mp3Data.file;

      // Use data URL for cached files (more reliable offline)
      console.log('üîÑ Converting MP3 to data URL for offline compatibility...');
      try {
        const dataURL = await loadMp3AsDataURL(mp3Data.file);
        console.log('‚úÖ Data URL created, length:', dataURL.length);

        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }

        audioPlayer.src = dataURL;
        audioPlayer.load(); // Force load
        console.log('üéµ Audio player src set to data URL');
        console.log('üéµ Audio player ready state:', audioPlayer.readyState);
        console.log('üéµ Audio player network state:', audioPlayer.networkState);

        fileTracker.mp3 = true;
        console.log('‚úÖ MP3 restored from cache with data URL');
        checkAllFilesLoaded();

        // Show manual button if it doesn't load after 5 seconds
        setTimeout(() => {
          if (audioPlayer.readyState === 0) {
            console.warn('‚ö†Ô∏è Audio not loading automatically, showing manual load button');
            forceLoadAudioButton.style.display = 'block';
          }
        }, 5000);
      } catch (err) {
        console.error('‚ùå Failed to create data URL, falling back to blob:', err);
        // Fallback to blob URL
        const url = URL.createObjectURL(mp3Data.file);
        audioPlayer.src = url;
        audioPlayer.load();
        fileTracker.mp3 = true;
        checkAllFilesLoaded();
        forceLoadAudioButton.style.display = 'block';
      }
    }

    // Restore JSON
    const jsonData = await loadFileFromIndexedDB('json');
    if (jsonData && jsonData.file) {
      document.getElementById('json-file-name').textContent = jsonData.name;

      const fileReader = new FileReader();
      fileReader.onload = function() {
        try {
          const data = JSON.parse(this.result);
          if (data && data.sentences && Array.isArray(data.sentences)) {
            manifest = data.sentences;
            fileTracker.json = true;
            console.log('‚úÖ JSON manifest restored from cache');
            checkAllFilesLoaded();
          } else {
            console.warn('‚ö†Ô∏è Cached JSON has invalid format');
          }
        } catch (err) {
          console.error('‚ùå Error parsing cached JSON:', err);
        }
      };
      fileReader.readAsText(jsonData.file);
    }

    // Check storage usage
    await checkStorageUsage();

  } catch (err) {
    console.error('‚ùå Error restoring files from IndexedDB:', err);
  }
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(registration => {
        console.log('‚úÖ Service Worker registered successfully:', registration.scope);

        // Check for updates periodically
        setInterval(() => {
          registration.update();
        }, 60000); // Check every minute

        // Handle service worker updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker available, show update notification
              if (confirm('New version available! Reload to update?')) {
                newWorker.postMessage({ type: 'SKIP_WAITING' });
                window.location.reload();
              }
            }
          });
        });
      })
      .catch(error => {
        console.log('‚ùå Service Worker registration failed:', error);
      });

    // Handle service worker controller change (new SW activated)
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      console.log('üîÑ Service Worker controller changed, reloading page...');
      window.location.reload();
    });
  });
}

// Add to home screen prompt (for supported browsers)
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  console.log('üíæ Install prompt available');
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;

  // Optionally, show your own install button
  // You could add a button in the UI here to trigger installation
});

window.addEventListener('appinstalled', () => {
  console.log('‚úÖ PWA installed successfully!');
  deferredPrompt = null;
});

// Alternative: Load MP3 as base64 data URL (more compatible offline)
async function loadMp3AsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Force load audio button handler
forceLoadAudioButton.addEventListener('click', async () => {
  console.log('üîÑ Manually forcing audio load...');
  forceLoadAudioButton.textContent = '‚è≥ Loading...';
  forceLoadAudioButton.disabled = true;

  if (!currentMp3File) {
    console.error('‚ùå No MP3 file available to load');
    forceLoadAudioButton.textContent = '‚ùå No File Available';
    return;
  }

  try {
    // Try data URL approach
    console.log('Converting to data URL...');
    const dataURL = await loadMp3AsDataURL(currentMp3File);
    console.log('‚úÖ Data URL created, setting as audio source...');

    audioPlayer.src = dataURL;
    audioPlayer.load();

    // Wait for it to load
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);

      audioPlayer.addEventListener('canplay', () => {
        clearTimeout(timeout);
        resolve();
      }, { once: true });

      audioPlayer.addEventListener('error', () => {
        clearTimeout(timeout);
        reject(audioPlayer.error);
      }, { once: true });
    });

    console.log('‚úÖ Audio loaded successfully!');
    forceLoadAudioButton.style.display = 'none';
    forceLoadAudioButton.disabled = false;
    forceLoadAudioButton.textContent = 'üîÑ Force Load Audio';
    showStatus('Audio loaded successfully!', false, false);
    setTimeout(() => statusBox.style.display = 'none', 2000);

  } catch (err) {
    console.error('‚ùå Manual load failed:', err);
    forceLoadAudioButton.textContent = '‚ùå Load Failed - Try Again';
    forceLoadAudioButton.disabled = false;
    showStatus('Failed to load audio: ' + err.message, false, true);
  }
});

// Restore files from IndexedDB on page load
window.addEventListener('load', () => {
  restoreFilesFromIndexedDB();
});

// Reset data button handler
document.getElementById('reset-data-button').addEventListener('click', async () => {
  const confirmed = confirm('‚ö†Ô∏è This will delete all cached files (PDF, MP3, JSON). You will need to re-upload them to use the app offline.\n\nAre you sure you want to continue?');

  if (!confirmed) {
    return;
  }

  try {
    showStatus('Clearing all cached data...', true, false);

    // Clear IndexedDB
    await clearAllIndexedDBData();

    // Clear service worker cache
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
      console.log('‚úÖ Service Worker caches cleared');
    }

    // Reset UI
    document.getElementById('pdf-file-name').textContent = 'No file selected';
    document.getElementById('mp3-file-name').textContent = 'No file selected';
    document.getElementById('json-file-name').textContent = 'No file selected';

    // Reset application state
    pdfDoc = null;
    manifest = null;
    fileTracker = { pdf: false, mp3: false, json: false };
    currentAudioPage = null;
    currentUserPage = null;
    pageViewports = {};

    // Clear PDF viewer
    pdfContainer.innerHTML = '';
    viewerPlaceholder.style.display = 'block';

    // Clear audio player
    if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
      URL.revokeObjectURL(audioPlayer.src);
    }
    audioPlayer.src = '';
    audioPlayer.disabled = true;

    // Update displays
    updatePageDisplays();

    showStatus('‚úÖ All cached data cleared successfully!', false, false);
    setTimeout(() => {
      statusBox.style.display = 'none';
    }, 3000);

    console.log('‚úÖ All data reset complete');

  } catch (err) {
    console.error('‚ùå Error clearing data:', err);
    showStatus('Error clearing data: ' + err.message, false, true);
  }
});
</script>
</body>
</html>